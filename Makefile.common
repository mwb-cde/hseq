###################################################### --*- Makefile -*--
# Makefile.common - Common make rules for HSeq
# Copyright 11 March, 2011, Matthew Wahab <mwb.cde@gmail.com>
#
# Released under the Lesser GPLv3 license:
# ========================================
# This file is part of HSeq.
#
# HSeq is free software; you can redistribute it and/or modify it
# under the terms of the Lesser GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# HSeq is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
# License for more details.
#
# You should have received a copy of the Lesser GNU General Public
# License along with HSeq.  If not see <http://www.gnu.org/licenses/>.
######################################################################

#####
# Common definitions and rules for Makefiles
#
# Requirements:
# -------------
#
# LEVEL: Variable containing relative path to top of the source tree.
#####

##
# Build commands
##

# BAREMAKE: The make with no options
export BAREMAKE = $(MAKE)

# DMAKE: The make to build sub-directories with.
#export DMAKE = make $(MAKEOPTIONS)
export DMAKE = $(MAKE)

# MAKECLEAN: The make to clean up with
export MAKECLEAN = $(MAKE) NODEPEND=true $(MAKEOPTIONS)

##
# OS Commands
##

# CD: Change directory
export CD = cd

# MKDIR: Make a directory
export MKDIR = mkdir -p

# RMDIR: Remove a directory
export RMDIR = rmdir

# COPY: Copy one or more files
export COPY = cp -f

# RM: Delete one or more files
export RM = rm -f

# SKIP: Do nothing
export SKIP =

##
# Build Targets
##

## General targets

.PHONY: all  	# all: Build everything
.PHONY: lib  	# lib: Build the library file
.PHONY: opt  	# opt: Build the native code library file
.PHONY: install # install: Install the library and header files.
.PHONY: doc  	# doc: Generate the code documentation

## Cleaning targets
.PHONY: clean
.PHONY: libclean
.PHONY: docclean
.PHONY: distclean

## build targets

.PHONY: build-headers 
.PHONY: build-code build-bytecode build-natcode
.PHONY: build-bytelib build-natlib build-lib

.PHONY: install-headers 
.PHONY: install-code install-bytecode install-natcode
.PHONY: install-bytelib install-natlib install-lib
.PHONY: install-other

#####
# Constants
#####

# LEVEL: Relative path to the top of the source tree is required.
ifndef LEVEL
$(error "Error: variable LEVEL not set when using Makefile in directory $(PWD)")
endif

# CONFIGDIR: The configuration directory
CONFIGDIR = $(LEVEL)/config

# CONFIGFILE: Configuration data file 
CONFIGFILE = $(CONFIGDIR)/data.make

###
# Configuration variables
# Set by data.make
###

ifndef CONFIGFILE
$(error "CONFIGFILE not defined")
endif

# Read $(CONFIGFILE)
include $(CONFIGFILE)

ifndef BinDir
$(error "BinDir not defined")
endif

####
# Compiler settings
####

#
# Flags:
#   FAST: Use the fast compilers
#
# Options:
#   OCAMLC_OPTIONS: options for ocamlc
#   OCAMLNAT_OPTIONS: options for ocamlopt (native code compiler)
#   OCAMLLINK_OPTIONS: options for ocamlc (linker)
#   OCAMLNATLINK_OPTIONS: options for ocamlnat (linker)
#   OCAMLDEP_OPTIONS: options for ocamldep
#   OCAMLDOC_OPTIONS: options for ocamldoc
#   OCAMLPP_OPTIONS : options to pass to camlp4
#

## Feature tests

# Whether camlp4 is old.
ifndef OLDCAMLP4
# Get the version of camlp4
export CAMLP4VERSION = OcamlVersion
ifeq ($(findstring CAMLP4VERSION,3.11),'')
export OLDCAMLP4 = false
else
export OLDCAMLP4 = true
endif
endif # OLDCAMLP4

## Tool and option selection 

# Use the camlp4 version to select the correct 
# prepropcessor options.
ifeq ($(OLDCAMLP4),true)
PPOPTIONS ?= -pp "camlp4o q_MLast.cmo pa_extend.cmo" -I +camlp4 
else
PPOPTIONS ?= -pp "camlp4of" -I +camlp4
endif

# BAREOCAMLC: The bare OCaml bytecode compiler
export BAREOCAMLC=ocamlc

# BAREOCAMLNAT: The bare OCaml native-code compiler
export BAREOCAMLNAT=ocamlopt

# OCAMLC: The OCaml byte code compiler
export OCAMLC=$(BAREOCAMLC) $(OCAMLC_OPTIONS)

# OCAMLNAT: The OCaml native code compiler
export OCAMLNAT=$(BAREOCAMLNAT) $(OCAMLNAT_OPTIONS) 

# OCAMLlink: The OCaml byte-code linker
export OCAMLLINK=$(BAREOCAMLC) -a 

# OCAMLMKTOP: Make a toplevel
export OCAMLMKTOP=ocamlmktop $(OCAMLMKTOP_OPTIONS)

# OCAMLDEP: The OCaml dependency generator
export OCAMLDEP=ocamldep $(OCAMLDEP_OPTIONS)

# OCAMLCPP : the preprocesor
export OCAMLCPP=camlp4 pa_o.cmo pr_o.cmo pa_extend.cmo pa_macro.cmo $(OCAMLCPP_OPTIONS)

# OCAMLDOC: The documentation generator
export OCAMLDOC=ocamldoc $(OCAMLDOC_OPTIONS)

###
# Native code compilers, only if supported
#
ifeq '$(FAST)' 'true'

# BAREOCAMLC: The bare OCaml bytecode compiler
export BAREOCAMLC=ocamlc.opt 

# BAREOCAMLNAT: The bare OCaml native-code compiler
export BAREOCAMLNAT=ocamlopt.opt

# OCAMLC: The OCaml bytecode compiler
export OCAMLC=$(BAREOCAMLC) $(OCAMLC_OPTIONS) 

# OCAMLNAT: The OCaml native code compiler
export OCAMLNAT=$(BAREOCAML) $(OCAMLNAT_OPTIONS) 

# OCAMLNATLINK: The OCaml native-code linker
export OCAMLNATLINK=$(OCAMLNAT) -a 

# OCAMLDEP: The OCaml dependency generator
export OCAMLDEP=ocamldep.opt $(OCAMLDEP_OPTIONS)

# OCAMLDOC: The documentation generator
export OCAMLDOC=ocamldoc.opt $(OCAMLDOC_OPTIONS)

endif # End of native code compilers
###

#####
# Build rules
#####

####
# Utility functions
####

# mlfile: Add ML source suffix to a name
export mlfile = $(addsuffix .ml,$(1))

# header: Add ML header suffix to a name
export header = $(addsuffix .mli,$(1))

# interface: Add ML object interface suffix to a nanme
export interface = $(addsuffix .cmi,$(1))

# bytecode: Add ML object file suffix to a name
export bytecode = $(addsuffix .cmo,$(1))

# natcode: Add ML native-code file suffix to a name
export natcode = $(addsuffix .cmx,$(1))

# objcode: Add system object-code suffix to a name
export objcode = $(addsuffix .o,$(1))

# bytelib: Add byte-lib suffix to a name
export bytelib = $(addsuffix .cma,$(1))

# natlib: Add native-lib suffix to a name
export natlib = $(addsuffix .cmxa,$(1))

# objlib: Add object-lib suffix to a name
export objlib = $(addsuffix .a,$(1))

##
# Suffixes and their build rules.
##

.SUFFIXES: .mli .cmi
.SUFFIXES: .ml .cmo
.SUFFIXES: .cma 
.SUFFIXES: .cmx 
.SUFFIXES: .cmxa 
.SUFFIXES: .mlp

.mlp.ml:
	$(OCAMLCPP) -impl $< -o $@

.mli.cmi: 
	$(OCAMLC) -c $<

.ml.cmo: 
	$(OCAMLC) -c $<

.ml.cmx: 
	$(OCAMLNAT) -c $<

####
# Templates for use with Makefile.module
####

#
# Build order:
#
# 1) Run the preprocessor on .mlp files.
#
# 2) Build interface from .mli files.
#
#    This has to be done before building object files otherwise ocaml
#    will generate an interface for each .ml file as it is compile,
#    possibly exposing values that were meant to be internal to the
#    .ml file.
#
# 3) Build objects from .ml files.
#
# 4) Build libraries from .ml files.
#
# Notes:
#
# Native code compilation should use the -dllpath option to ocamlc to
# pass the library install-directory. This is needed so that the
# libraries can be found after installation.
#

# build_header_template($1): Build headers for $(1) from names in $(1)_SOURCES
define build_header_template
build-headers-$(1): $$(call interface,$(1)_SOURCES)
endef

# build_bytecode_template($1): Build byte-code objects for $(1) from
# names in $(1)_SOURCES
define build_bytecode_template
build-bytecode-$(1): $$(call bytecode,$(1)_SOURCES)
endef

# build_bytelib_template($1): Build byte-code library for $(1) from
# names in $(1)_SOURCES
define build_bytelib_template
$(call bytelib,$(1)): $$(call bytecode,$(1)_SOURCES)
	$(OCAMLLINK) $(OCAMLINCLUDE) -o $(call bytelib,$(1)) $$(call bytecode,$(1)_SOURCES)
#
build-bytelib-$(1): $(call bytelib,$(1))
endef

# build_natcode_template($1): Build native-code objects for $(1) from
# names in $(1)_SOURCES
define build_natcode_template
$(call natlib,$(1)): $$(call natcode,$(1)_SOURCES)
	$(OCAMLNATLINK) $(OCAMLNATLINK_OPTIONS) -o $(call natlib, $1) \
		$$(call natcode,$(1)_SOURCES)
build-natcode-$(1): $(call natlib,$(1))
endef

####
# Use the templates to build everything in Makefile.module
#

##
# Run the sub-directories.
ifneq ($(strip $(SUBDIRS)),"")
module_has_subdirs=1
endif

ifdef module_has_subdirs
depend-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) depend ; )

build-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) build ; )

install-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) install ; )

clean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) clean ; )

libclean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) libclean ; )

distclean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) distclean ; )
endif

## 
# Build the headers, first for the libraries and then for the programs.
module_headers=\
	$(foreach lib,$(LIBRARIES),$(call interface,$(lib_SOURCES))) \
	$(foreach program,$(PROGRAMS),$(call interface,$(program_SOURCES)))

build_module_headers: $(module_headers)

