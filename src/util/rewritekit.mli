(*-----
   Name: rewritekit.mli
   Author: M Wahab <mwahab@users.sourceforge.net>
   Copyright M Wahab 2006
   ----*)

(** Directed Rewriting *)

exception Stop of exn
exception Quit of exn

(** {5 Rewriting plans} *)

    (** The specification of a rewriting plan *)
type ('k, 'a)plan =
    Node of 'k * (('k, 'a)plan list)
	(** The rewriting plan for a kind of node *)
  | Rules of 'a list
	(** The rules to use to rewrite the current node *)
  | Branch of (int * ('k, 'a)plan)
	(** The rewriting plan for the branch of a node *)
  | Branches of ('k, 'a)plan list
	(** The rewriting plans for all branches of the node *)
  | Skip  (** The null rewriting plan *)
      (** 
	 A rewrite plan specificies how a node [n] is to
	 be rewritten in terms of the rules to be applied
	 to each sub-node [n].

	 Plans are keyed to particular kinds of node. If a
	 plan [p] is applied to node [n] which does not
	 have the right key, the sub-nodes of [n] are
	 searched for a node with the right key. The
	 search is top-down and left-right and the test on
	 keys uses predicate [A.is_key]. It is therefore
	 possible to direct the search using plans and an
	 appropriate value for [A.is_key].

	 Rules for rewriting node [n] by plan [p],
	 starting with the initial data [d]:
	 
	 {b [p=Node(k, ps)]}: If [is_key k n]: for each
	 [x] in [ps], rewrite [n] with [x] and [d] to get
	 new node [n'] and data [d'].
	 
	 If [not(is_key k n)]: Let [ns] be the subnodes of
	 [n].  Try rewriting each [x] in [ns], starting
	 with the left-most, and return the result of the
	 first which does not raise [Not_found]. If all
	 subnodes in [ns] fail with [Not_found] then raise
	 [Not_found]. 

	 {b [p=Rules rs]}: Rewrite node [n] with each rule
	 in [rs] in order. If either [matches] or [subst]
	 raise [Stop] then stop rewriting and return the
	 result so far. If either [matches] or [subst]
	 raise [Quit e] then abandon the attempt and fail,
	 raising [e].

	 {b [p=Branch(i, p)]}: Replace the [i]'th subnode
	 of [n] with the result of rewriting the subnode
	 using plan [p]. (The left-most subnode of [n] is
	 the [0]'th.)

	 {b [p=Branches(ps)]}: Rewrite each subnode of [n]
	 with the matching plan in [ps]. If there are more
	 plans then subnodes, ingore the extra plans. If
	 there are more subnodes, use the extra sub-nodes
	 unchanged.
	 
	 {b [p=Skip]}: Do nothing, succeeding quietly.
       *)

val mapping : ('a -> 'b) -> ('k, 'a)plan -> ('k, 'b)plan
    (** [mapping f p]: Map [f] over rules of plan [p]. *)

(*
   val map : (('k, 'a)plan -> ('k, 'b)plan) -> ('k, 'a)plan -> ('k, 'b)plan
   (** [map f p]: Map [f] over plan [p]. *)
 *)

val iter : (('k, 'a)plan -> unit) -> ('k, 'a)plan -> unit
    (** [iter f p]: Iterate [f] over plan [p]. *)

(** {7 Rewrite functions data} *)

module type Data =
  sig
    type node  (** Nodes to be rewritten *)
    type rule  (** Rewrite rules *)
    type data  (** Data used in matching/substitution *)
    type substn (** The substition generated by a match *)
    type key   (** Node identifiers, for use in a plan *)

    val key_of : node -> key
	(** [key_of n]: Get an identifier for [n] *)

    val is_key : key -> node -> bool
	(** [is_key k n]: Test whether node [n] matches key [k] *)

    val num_subnodes : node -> int
(** [num_subnodes n]: The number of subnodes of [n]. *)

    val subnodes_of : node -> node list
(** [subnodes_of n]: Get the list of subnodes of [n] *)

    val set_subnodes : node -> node list -> node
(** 
   [set_subnodes n xs]: Set subnodes of [n] to [xs], replacing the
   [i]'th subnode of [n] with the [i]'th element of [xs]. Fails with
   [Quit] if the number of new nodes in [xs] is not the same as the
   number of subnodes.
 *)

    val get_subnode : node -> int -> node
(** 
   [get_subnode n i]: Get subnode [i] of node [n]. Subnodes are
   counted from the left and starting from [0]
 *)

    val set_subnode : node -> int -> node -> node
(** 
   [set_subnode n i x]: set subnode [i] of [n] to [x]. Subnodes are
   counted from the left and starting from [0]
 *)

    val matches : 
	data -> rule -> node -> (data * substn) 
(** [matches data r n]: Try to match node [n] with rule [r].
   
   [data] is extra data to pass to [matches]. [r] is the rewrite rule
   being tried.  Returns [(new_data, env)] where [new_data] is to be
   passed on to the next application of [matches] or [subst] and [env]
   is the substitution to be passed to [subst].
 *)
	    
    val subst :
	data -> rule -> substn -> (data * node)
(** [subst data env rhs]: Apply the substitutions in [env] to rule [r]
   to get a new node.
   
   [data] is extra data to pass to [subst], usually generated from the
   last invocation of [matches]. [env] is the substitution generated
   from an invocation of [matches] and [r] is the matched rewrite
   rule.  Returns [(new_data, n)] where [new_data] is to be passed on
   to the next application of [matches] or [subst] and [n] is the
   result of the substititution
 *)

    val add_data : data -> node -> data
(** 
   [add_data data n]: Add to data from node [n]. Called for each node
   before any rewriting takes place. Resulting data is used in
   matching/substitutions for subnodes.
 *)

    val drop_data : (data * node) -> (data * node) -> data
(** 
   [drop_data (d1, n1) (d2, n2)]: Drop data generated from a
   node. Called for each node before all rewriting of the node has
   completed. Node [n1] is the original node and [d1] is original
   data. Node [n2] and data [d2] are the result of rewriting [n1]
   using data [d1].
 *)
  end


(** {7 Rewrite functions} *)

module type Kit =
  sig

    type data 
    type rule 
    type node 
    type substn 
    type key 

    val is_key : key -> node -> bool
    val node_matches : 
	data -> rule -> node -> (data * substn) 
    val node_subst :
	data -> rule -> substn -> (data * node)
    val subnodes_of : node -> node list
    val set_subnodes : node -> node list -> node
    val get_subnode : node -> int -> node
    val set_subnode : node -> int -> node -> node
    val add_data : data -> node -> data
    val drop_data : (data * node) -> (data * node) -> data

    val rewrite_first :
	data -> (key, rule)plan -> node list 
	  -> (data * (node list))
    val rewrite_branches : 
	data -> node list -> (key, rule)plan list
	  -> (data * (node list))
    val rewrite_rules :
	(data * node) -> rule list -> (data * node)
    val rewrite_aux :
	(data * node) -> (key, rule)plan
	  -> (data * node)
    val rewrite :
	data -> (key, rule)plan -> node -> (data * node)
  end

module Make : 
functor (A : Data) -> 
  (Kit with type data = A.data
  and type rule = A.rule
  and type node = A.node
  and type substn = A.substn
  and type key = A.key)
