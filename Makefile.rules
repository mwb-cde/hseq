###################################################### --*- Makefile -*--
# Makefile.rules - Common make rules for building HSeq modules
# Copyright 12 March, 2011, Matthew Wahab <mwb.cde@gmail.com>
#
# Released under the Lesser GPLv3 license:
# ========================================
# This file is part of HSeq.
#
# HSeq is free software; you can redistribute it and/or modify it
# under the terms of the Lesser GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# HSeq is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
# License for more details.
#
# You should have received a copy of the Lesser GNU General Public
# License along with HSeq.  If not see <http://www.gnu.org/licenses/>.
######################################################################

#####
# Definitions and rules for Makefiles that build modules.
#
# This Makefile provides the necessary infrastructure for building modules
# and should be included from instances of Makefile.module.
#
# Requirements:
# PROJ_ROOT: Variable containing relative path to top of the source tree.
#####

###
# Default target
###
.PHONY: all
all: build

###
# Include the common settings.
#

# PROJ_ROOT: Relative path to the top of the source tree is required.
ifndef PROJ_ROOT
$(error "Error: variable PROJ_ROOT not set when using Makefile in directory $(PWD)")
endif

include $(PROJ_ROOT)/Makefile.common

####
# Templates for building module objects
####

#
# Targets:
# --------
#
# all: synonymous with build.
# build: Build the module. (required)
# install: Install the module. (required)
# doc: Generate documentation.
# clean: Delete all built objects.
# libclean: Delete libraries only.
# distclean: Pristine clean.
# depend: Calculate dependencies
#

#
# Build order:
#
# 1) Run the preprocessor on .mlp files.
#
# 2) Build interface from .mli files.
#
#    This has to be done before building object files otherwise ocaml
#    will generate an interface for each .ml file as it is compile,
#    possibly exposing values that were meant to be internal to the
#    .ml file.
#
# 3) Build objects from .ml files.
#
# 4) Build libraries from .ml files.
#
# Notes:
#
# Native code compilation should use the -dllpath option to ocamlc to
# pass the library install-directory. This is needed so that the
# libraries can be found after installation.
#

# build-header-template($1): Build headers for $(1) from names in $(1)_SOURCES
define build-header-template
.PHONY: build-headers-$(1)
build-headers-$(1): $$(call interface,$(1)_SOURCES)
endef

# build-bytecode-template($1): Build byte-code objects for $(1) from
# names in $(1)_SOURCES
define build-bytecode-template
.PHONY: build-bytecode-$(1)
build-bytecode-$(1): $$(call bytecode,$(1)_SOURCES)
endef

# build-bytelib-template($1): Build byte-code library for $(1) from
# names in $(1)_SOURCES
define build-bytelib-template
$(1)_OPTIONS=$$($(1)_OCAMLC_FLAGS) $$(foreach file,$$($(lib)_INCLUDE),-I $$(file) )
$$(info "$(1)_OPTIONS = $$($(1)_OPTIONS)")
FILE_OCAMLC_OPTIONS=$$($(1)_OPTIONS)
$$(info "FILE_OCAMLC_OPTIONS = $$(FILE_OCAMLC_OPTIONS)")
$$(info "OCAMLC = $$(OCAMLC)")

bytelib-$(1)-interfaces:=$$(foreach src,$$($(1)_SOURCES),$$(call interface,$$(src)))
bytelib-$(1)-objects:=$$(foreach src,$$($(1)_SOURCES),$$(call bytecode,$$(src)))
bytelib-$(1)-lib=$(call bytelib,$(1))
ifeq ($$(strip $$(MODULE_USE_OBJDIR)),yes)
# Use staging directory
bytelib-$(1)-target=$$(OBJ_ROOT)/$$(bytelib-$(1)-lib)
$$(bytelib-$(1)-target): $$(OBJ_ROOT) $$(bytelib-$(1)-lib)
	$$(COPY) $$(bytelib-$(1)-interfaces) $$(OBJ_ROOT)
	$$(COPY) $$(bytelib-$(1)-lib) $$(OBJ_ROOT)
else
# Don't use staging directory
bytelib-$(1)-target=$$(bytelib-$(1)-lib)
endif
# Build rule for the library.
$$(bytelib-$(1)-lib): $$(bytelib-$(1)-objects)
	$$(OCAMLLINK) $$(OCAMLINCLUDE) -o $$(bytelib-$(1)-lib) $$(bytelib-$(1)-objects)
# Standard build rule.
.PHONY: build-bytelib-$(1)
build-bytelib-$(1): $$(bytelib-$(1)-target)
endef

# build-natcode-template($1): Build native-code objects for $(1) from
# names in $(1)_SOURCES.
define build-natcode-template
natlib_$(1)_objects=$$(foreach src,$$($(1)_SOURCES),$$(call natcode,$$(src)))
$(call natlib,$(1)): 
	$$(OCAMLNATLINK) $$(OCAMLNATLINK_OPTIONS) -o $(call natlib, $1) \
		$$(natlib_$(1)_objects)
.PHONY: build-natcode-$(1)
build-natcode-$(1): $(call natlib,$(1))
endef

# build-byteprog-template($1): Build byte-code program for $(1) from
# names in $(1)_SOURCES
define build-byteprog-template
byteprog_$(1)_objects=$$(foreach src,$$($(1)_SOURCES),$$(call bytecode,$$(src)))
$(1): $$(byteprog_$(1)_objects)
	$$(OCAMLC) $$($(1)_OCAMLC_FLAGS) -o $(1) $$(($1)_INCLUDE)\
		$$($(1)_LIBS) $$(byteprog_$(1)_objects)
#
.PHONY: build-byteprog-$(1)
build-byteprog-$(1): $(1)
endef

####
# Use the templates to build everything in Makefile.module
#

##
# Run the sub-directories.
ifneq ($(strip $(SUBDIRS)),"")
module_has_subdirs=1
endif

ifdef module_has_subdirs
.PHONY: depend-subdirs
depend-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) depend ; )

.PHONY: build-subdirs
build-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) build ; )

.PHONY: install-subdirs
install-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) install ; )

.PHONY: clean-subdirs
clean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) clean ; )

.PHONY: libclean-subdirs
libclean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) libclean ; )

.PHONY: distclean-subdirs
distclean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) distclean ; )
endif

###
# Debugging information
#

$(info "MAKEFILE DEBUGGING")
$(info "LIBRARIES = $(LIBRARIES)")
$(info "PROGRAMS = $(PROGRAMS)")

###
# Instantiate the targets
#

# module_lib_sources: All library sources
module_lib_sources=$(foreach lib,$(LIBRARIES),$($(lib)_SOURCES))

# module_prog_sources: All program sources
module_prog_sources=$(foreach prog,$(PROGRAMS),$($(prog)_SOURCES))

# module_sources: All sources, with library sources first
module_sources=$(module_lib_sources) $(module_prog_sources)

# module_mlsources: All ml sources, with library sources first
module_mlsources=$(foreach src,$(module_sources),$(call mlfile,$(src)))

# module_headers: All headers, with library headers first
module_headers= $(foreach src,$(module_sources),$(call header,$(src)))

# module_interfaces: All headers, with library headers first
module_interfaces=$(foreach source,$(module_sources),$(call interface,$(source)))

# module_libobjs: Bytecode files needed to build the libraries
module_libobjs: $(foreach source,$(lib_SOURCES),$(call bytecode,$source))

$(info "module_lib_sources = $(module_lib_sources)")
$(info "module_prog_sources = $(module_prog_sources)")
$(info "module_interfaces = $(module_interfaces)")
$(info "module_headers = $(module_headers)")
$(info "module_mlsources = $(module_mlsources)")

##
# Instantiate build targets and settings for libraries
$(foreach lib,$(LIBRARIES),\
$(eval $(call build-bytelib-template,$(lib))))

##
# Instantiate build targets for programs
$(foreach prog,$(PROGRAMS),\
	$(eval $(call build-byteprog-template,$(prog))))

#
# Directories
#

$(OBJ_ROOT):
	$(MKDIR) $(OBJ_ROOT)

.PHONY: build-objdir
build-objdir: $(OBJ_ROOT)

#
# Libraries
#

.PHONY: build-headers
build-headers: $(module_interfaces)

.PHONY: build-bytelibs
build-bytelibs: $(module_interfaces) $(foreach lib,$(LIBRARIES),build-bytelib-$(lib) )

.PHONY: build-programs
build-programs: $(module_interfaces) $(foreach prog,$(PROGRAMS),build-byteprog-$(prog) )

##
# Dependencies
# Define NODEPEND to prevent using depend
##

depend: $(module_headers) $(module_mlsources)
	-$(OCAMLDEP) $(module_headers) $(module_mlsources) > depend

ifndef NODEPEND
include depend
endif

###
# Clean up
###

clean: 
	$(foreach subdir, $(SUBDIRS), \
		$(MAKE) -C $(subdir) clean; )
	-$(RM) *.cmo *.cmx *.o *~

libclean: clean
	$(foreach subdir, $(SUBDIRS), \
		$(MAKE) -C $(subdir) libclean; )
	-$(RM) *.cmi *.cma *.cmxa *~

distclean: clean libclean
	$(foreach subdir, $(DOCSUBDIRS), \
		$(MAKE) -C $(subdir) reallyclean; )
	-$(RM) depend

###
# Toplevel targets

.PHONY: build
build: build-objdir build-headers build-bytelibs build-programs
