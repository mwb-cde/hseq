###################################################### --*- Makefile -*--
# Makefile.rules - Common make rules for building HSeq modules
# Copyright 12 March, 2011, Matthew Wahab <mwb.cde@gmail.com>
#
# Released under the Lesser GPLv3 license:
# ========================================
# This file is part of HSeq.
#
# HSeq is free software; you can redistribute it and/or modify it
# under the terms of the Lesser GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# HSeq is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
# License for more details.
#
# You should have received a copy of the Lesser GNU General Public
# License along with HSeq.  If not see <http://www.gnu.org/licenses/>.
######################################################################

#####
# Definitions and rules for Makefiles that build modules.
#
# This Makefile provides the necessary infrastructure for building modules
# and should be included from instances of Makefile.module.
#
# Requirements:
# PROJ_ROOT: Variable containing relative path to top of the source tree.
#####

###
# Default target
###
.PHONY: all
all: build

###
# Include the common settings.
#

# PROJ_ROOT: Relative path to the top of the source tree is required.
ifndef PROJ_ROOT
$(error "Error: variable PROJ_ROOT not set when using Makefile in directory $(PWD)")
endif

include $(PROJ_ROOT)/Makefile.common

####
# Templates for building module objects
####

#
# Targets:
# --------
#
# all: synonymous with build.
# build: Build the module. (required)
# install: Install the module. (required)
# doc: Generate documentation.
# clean: Delete all built objects.
# libclean: Delete libraries only.
# distclean: Pristine clean.
# depend: Calculate dependencies
#

#
# Build order:
#
# 1) Run the preprocessor on .mlp files.
#
# 2) Build interface from .mli files.
#
#    This has to be done before building object files otherwise ocaml
#    will generate an interface for each .ml file as it is compile,
#    possibly exposing values that were meant to be internal to the
#    .ml file.
#
# 3) Build objects from .ml files.
#
# 4) Build libraries from .ml files.
#
# Notes:
#
# Native code compilation should use the -dllpath option to ocamlc to
# pass the library install-directory. This is needed so that the
# libraries can be found after installation.
#

# build-header-template($1): Build headers for $(1) from names in $(1)_SOURCES
define build-header-template
.PHONY: build-headers-$(1)
build-headers-$(1): $$(call interface,$(1)_SOURCES)
endef

# build-bytecode-template($1): Build byte-code objects for $(1) from
# names in $(1)_SOURCES
define build-bytecode-template
.PHONY: build-bytecode-$(1)
build-bytecode-$(1): $$(call bytecode,$(1)_SOURCES)
endef

# build-bytelib-template($1): Build byte-code library for $(1) from
# names in $(1)_SOURCES
define build-bytelib-template

# Bytecode libraries
bytelib-$(1)-interfaces:=$$(foreach src,$$($(1)_SOURCES),$$(call interface,$$(src)))
bytelib-$(1)-objects:=$$(foreach src,$$($(1)_SOURCES),$$(call bytecode,$$(src)))
bytelib-$(1)-lib:=$(call bytelib,$(1))
bytelib-$(1)-ocamlc-options:=$$(module-ocamlc-options) $$($(1)_OCAMLC_FLAGS) \
	$$(foreach file,$$($(lib)_INCLUDE),-I $$(file))

$$(info "bytelib-$(1)-lib = $$(bytelib-$(1)-lib)")
$$(info "bytelib-$(1)-interfaces = $$(bytelib-$(1)-interfaces)")
$$(info "bytelib-$(1)-objects = $$(bytelib-$(1)-objects)")
$$(info "bytelib-$(1)-ocamlc-options = $$(bytelib-$(1)-ocamlc-options)")

ifdef module-uses-objdir
# Use staging directory
bytelib-$(1)-target=$$(module-obj-dir)/$$(bytelib-$(1)-lib)
$$(bytelib-$(1)-target): $$(module-obj-dir) $$(bytelib-$(1)-lib)
	$$(COPY) $$(bytelib-$(1)-interfaces) $$(module-obj-dir)
	$$(COPY) $$(bytelib-$(1)-lib) $$(module-obj-dir)
else
# Don't use staging directory
bytelib-$(1)-target=$$(bytelib-$(1)-lib)
endif

# Build rule for the library.
$$(bytelib-$(1)-lib): $$(bytelib-$(1)-objects)
	$$(OCAMLLINK) $$(OCAMLINCLUDE) -o $$(bytelib-$(1)-lib) $$(bytelib-$(1)-objects)
# Standard build rule.
.PHONY: build-bytelib-$(1)
build-bytelib-$(1): $$(bytelib-$(1)-target)
endef

# build-natcode-template($1): Build native-code objects for $(1) from
# names in $(1)_SOURCES.
define build-natcode-template
natlib_$(1)_objects=$$(foreach src,$$($(1)_SOURCES),$$(call natcode,$$(src)))
$(call natlib,$(1)): 
	$$(OCAMLNATLINK) $$(OCAMLNATLINK_OPTIONS) -o $(call natlib, $1) \
		$$(natlib_$(1)_objects)
.PHONY: build-natcode-$(1)
build-natcode-$(1): $(call natlib,$(1))
endef

# build-byteprog-template($1): Build byte-code program for $(1) from
# names in $(1)_SOURCES
define build-byteprog-template
byteprog_$(1)_objects=$$(foreach src,$$($(1)_SOURCES),$$(call bytecode,$$(src)))
$(1): $$(byteprog_$(1)_objects)
	$$(OCAMLC) $$($(1)_OCAMLC_FLAGS) -o $(1) $$(($1)_INCLUDE)\
		$$($(1)_LIBS) $$(byteprog_$(1)_objects)
#
.PHONY: build-byteprog-$(1)
build-byteprog-$(1): $(1)
endef

######
# Use the templates to build everything in Makefile.module
#

###
# Module settings
# 

# module-ocamlc-options: Module wide ocamlc flags.
module-ocamlc-options=$(global-ocamlc-options)

# module-uses-objdir: Defined iff the module uses a staging directory.
# module-obj-dir: The staging directory to use.
ifeq ($(strip $(MODULE_USE_OBJDIR)),yes)
module-uses-objdir=yes
module-obj-dir=$(OBJ_ROOT)
endif

# module-sources: All library and program sources, with library sources first
module-sources=$(foreach lib,$(LIBRARIES),$($(lib)_SOURCES)) \
	$(foreach prog,$(PROGRAMS),$($(prog)_SOURCES))

# module-mlsources: All ml sources, with library sources first
module-mlsources=$(foreach src,$(module-sources),$(call mlfile,$(src)))

# module-headers: All headers, with library headers first
module-headers= $(foreach src,$(module-sources),$(call header,$(src)))

# module_interfaces: All headers, with library headers first
module_interfaces=$(foreach source,$(module-sources),$(call interface,$(source)))

$(info "module-lib-sources = $(module-lib-sources)")
$(info "module-prog-sources = $(module-prog-sources)")
$(info "module_interfaces = $(module_interfaces)")
$(info "module-headers = $(module-headers)")
$(info "module-mlsources = $(module-mlsources)")

###
# Instantiate the targets
#

##
# Instantiate bytelib build targets for each target.
$(foreach lib,$(LIBRARIES),\
$(eval $(call build-bytelib-template,$(lib))))

##
# Instantiate build targets for byte-code programs
$(foreach prog,$(PROGRAMS),\
	$(eval $(call build-byteprog-template,$(prog))))

###
# Directories
#

$(module-obj-dir):
	$(MKDIR) $(module-obj-dir)

.PHONY: build-objdir
build-objdir: $(OBJ_ROOT)

#
# Libraries
#

.PHONY: build-headers
build-headers: $(module_interfaces)

.PHONY: build-bytelibs
build-bytelibs: $(module_interfaces) $(foreach lib,$(LIBRARIES),build-bytelib-$(lib) )

.PHONY: build-programs
build-programs: $(module_interfaces) $(foreach prog,$(PROGRAMS),build-byteprog-$(prog) )


###
# Clean up
###

clean: 
	$(foreach subdir, $(SUBDIRS), \
		$(MAKE) -C $(subdir) clean; )
	-$(RM) *.cmo *.cmx *.o *~

libclean: clean
	$(foreach subdir, $(SUBDIRS), \
		$(MAKE) -C $(subdir) libclean; )
	-$(RM) *.cmi *.cma *.cmxa *~

distclean: clean libclean
	$(foreach subdir, $(DOCSUBDIRS), \
		$(MAKE) -C $(subdir) reallyclean; )
	-$(RM) depend

###
# Toplevel targets

.PHONY: build
build: build-objdir build-headers build-bytelibs build-programs


##
# Run the sub-directories.
ifneq ($(strip $(SUBDIRS)),"")
module_has_subdirs=1
endif

ifdef module_has_subdirs
.PHONY: depend-subdirs
depend-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) depend ; )

.PHONY: build-subdirs
build-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) build ; )

.PHONY: install-subdirs
install-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) install ; )

.PHONY: clean-subdirs
clean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) clean ; )

.PHONY: libclean-subdirs
libclean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) libclean ; )

.PHONY: distclean-subdirs
distclean-subdirs:
	$(foreach name,$(SUBDIRS), $(MAKE) -C $(name) distclean ; )
endif

##
# Dependencies
# Define NODEPEND to prevent using depend
##

depend: $(module-headers) $(module-mlsources)
	-$(OCAMLDEP) $(module-headers) $(module-mlsources) > depend

ifndef NODEPEND
include depend
endif
