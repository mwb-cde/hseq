###################################################### --*- Makefile -*--
# Makefile.rules - Common make rules for building HSeq modules
# Copyright 12 March, 2011, Matthew Wahab <mwb.cde@gmail.com>
#
# Released under the Lesser GPLv3 license:
# ========================================
# This file is part of HSeq.
#
# HSeq is free software; you can redistribute it and/or modify it
# under the terms of the Lesser GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# HSeq is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the Lesser GNU General Public
# License for more details.
#
# You should have received a copy of the Lesser GNU General Public
# License along with HSeq.  If not see <http://www.gnu.org/licenses/>.
######################################################################

#####
# Definitions and rules for Makefiles that build modules.
#
# This Makefile provides the necessary infrastructure for building modules
# and should be included from instances of Makefile.module.
#
# Requirements:
# PROJ_ROOT: Variable containing relative path to top of the source tree.
#####

###
# Default target
###
.PHONY: all
all: build

###
# Include the common settings.
#

# PROJ_ROOT: Relative path to the top of the source tree is required.
ifndef PROJ_ROOT
$(error "Error: variable PROJ_ROOT not set when using Makefile in directory $(PWD)")
endif

include $(PROJ_ROOT)/Makefile.common

####
# Compiler settings
####

#
# Flags:
#   FAST: Use the fast compilers
#
# Options:
#   OCAMLC_FLAGS: options for ocamlc
#   OCAMLNAT_FLAGS: options for ocamlopt (native code compiler)
#   OCAMLLINK_FLAGS: options for ocamlc (linker)
#   OCAMLNATLINK_FLAGS: options for ocamlnat (linker)
#   OCAMLDEP_FLAGS: options for ocamldep
#   OCAMLDOC_FLAGS: options for ocamldoc
#   OCAMLPP_FLAGS : options to pass to camlp4
#

## Tool and option selection 

# Use the camlp4 version to select the correct 
# prepropcessor options.
ifeq ($(OLDCAMLP4),true)
PPOPTIONS ?= -pp "camlp4o q_MLast.cmo pa_extend.cmo" -I +camlp4 
else
PPOPTIONS ?= -pp camlp4of -I +camlp4
endif

# BAREOCAMLC: The bare OCaml bytecode compiler
export BAREOCAMLC=ocamlc

# BAREOCAMLNAT: The bare OCaml native-code compiler
export BAREOCAMLNAT=ocamlopt

# OCAMLC: The OCaml byte code compiler
export OCAMLC=$(BAREOCAMLC) $(OCAMLC_FLAGS) $(lm-file-ocamlc-options)

# OCAMLNAT: The OCaml native code compiler
export OCAMLNAT=$(BAREOCAMLNAT) $(OCAMLNAT_FLAGS) 

# OCAMLlink: The OCaml byte-code linker
export OCAMLLINK=$(BAREOCAMLC) -a 

# OCAMLMKTOP: Make a toplevel
export OCAMLMKTOP=ocamlmktop $(OCAMLMKTOP_FLAGS)

# OCAMLDEP: The OCaml dependency generator
export OCAMLDEP=ocamldep $(OCAMLDEP_FLAGS) $(lm-file-ocamldep-options)

# OCAMLCPP : the preprocesor
export OCAMLCPP=camlp4 pa_o.cmo pr_o.cmo pa_extend.cmo pa_macro.cmo $(OCAMLCPP_FLAGS)

# OCAMLDOC: The documentation generator
export OCAMLDOC=ocamldoc $(OCAMLDOC_FLAGS)

###
# Native code compilers, only if supported
#
ifeq '$(FAST)' 'true'

# # BAREOCAMLC: The bare OCaml bytecode compiler
# export BAREOCAMLC=ocamlc.opt 

# # BAREOCAMLNAT: The bare OCaml native-code compiler
# export BAREOCAMLNAT=ocamlopt.opt

# # OCAMLC: The OCaml bytecode compiler
# export OCAMLC=$(BAREOCAMLC) $(OCAMLC_FLAGS) $(lm-file-ocamlc-options)

# # OCAMLNAT: The OCaml native code compiler
# export OCAMLNAT=$(BAREOCAML) $(OCAMLNAT_FLAGS) 

# # OCAMLNATLINK: The OCaml native-code linker
# export OCAMLNATLINK=$(OCAMLNAT) -a 

# # OCAMLDEP: The OCaml dependency generator
# export OCAMLDEP=ocamldep.opt $(OCAMLDEP_FLAGS)

# # OCAMLDOC: The documentation generator
# export OCAMLDOC=ocamldoc.opt $(OCAMLDOC_FLAGS)

endif # End of native code compilers
###

#####
# Build rules
#####

####
# Utility functions
####

# mlfile: Add ML source suffix to a name
export mlfile=$(addsuffix .ml,$(1))

# header: Add ML header suffix to a name
export header=$(addsuffix .mli,$(1))

# interface: Add ML object interface suffix to a nanme
export interface=$(addsuffix .cmi,$(1))

# bytecode: Add ML object file suffix to a name
export bytecode=$(addsuffix .cmo,$(1))

# natcode: Add ML native-code file suffix to a name
export natcode=$(addsuffix .cmx,$(1))

# objcode: Add system object-code suffix to a name
export objcode=$(addsuffix .o,$(1))

# bytelib: Add byte-lib suffix to a name
export bytelib=$(addsuffix .cma,$(1))

# natlib: Add native-lib suffix to a name
export natlib=$(addsuffix .cmxa,$(1))

# objlib: Add object-lib suffix to a name
export objlib=$(addsuffix .a,$(1))

##
# Suffixes and their build rules.
##

.SUFFIXES: .mli .cmi
.SUFFIXES: .ml .cmo
.SUFFIXES: .cma 
.SUFFIXES: .cmx 
.SUFFIXES: .cmxa 
.SUFFIXES: .mlp

%.ml: %.mlp
	$(OCAMLCPP) -impl $< -o $@

%.cmi: %.mli
	$(OCAMLC) -c $<

%.cmo: %.ml
	$(OCAMLC) -c $<

%.cmx: %.ml
	$(OCAMLNAT) -c $<


####
# Templates for building module objects
####

#
# Targets:
# --------
#
# all: synonymous with build.
# build: Build the module. (required)
# install: Install the module. (required)
# doc: Generate documentation.
# clean: Delete all built objects.
# libclean: Delete libraries only.
# distclean: Pristine clean.
# depend: Calculate dependencies
#
#
# Build order:
#
# 1) Run the preprocessor on .mlp files.
#
# 2) Build interface from .mli files.
#
#    This has to be done before building object files otherwise ocaml
#    will generate an interface for each .ml file as it is compile,
#    possibly exposing values that were meant to be internal to the
#    .ml file.
#
# 3) Build objects from .ml files.
#
# 4) Build libraries from .ml files.
#
# Notes:
#
# Native code compilation should use the -dllpath option to ocamlc to
# pass the library install-directory. This is needed so that the
# libraries can be found after installation.
#

# subdir-targets-template($1): Targets for sub-directory $(1).
define subdir-targets-template

.PHONY: all-subdir-$(1)
all-subdir-$(1):
	$$(MAKE) -C $(1) all

.PHONY: depend-subdir-$(1)
depend-subdir-$(1):
	$$(MAKE) -C $(1) depend

.PHONY: build-subdir-$(1)
build-subdir-$(1):
	$$(MAKE) -C $(1) build

.PHONY: install-subdir-$(1)
install-subdir-$(1):
	$$(MAKE) -C $(1) install

.PHONY: clean-subdir-$(1)
clean-subdir-$(1):
	$$(MAKE) -C $(1) clean

.PHONY: libclean-subdir-$(1)
libclean-subdir-$(1):
	$$(MAKE) -C $(1) libclean

.PHONY: distclean-subdir-$(1)
distclean-subdir-$(1):
	$$(MAKE) -C $(1) distclean
endef

# build-header-template($1): Build headers for $(1) from names in $(1)_SOURCES
define build-header-template
.PHONY: build-headers-$(1)
build-headers-$(1): $$(call interface,$(1)_SOURCES)
endef

# build-bytecode-template($1): Build byte-code objects for $(1) from
# names in $(1)_SOURCES
define build-bytecode-template
.PHONY: build-bytecode-$(1)
build-bytecode-$(1): $$(call bytecode,$(1)_SOURCES)
endef

# build-bytelib-template($1): Build byte-code library for $(1) from
# names in $(1)_SOURCES
define build-bytelib-template

# Bytecode libraries
bytelib-$(1)-interfaces:=$$(foreach src,$$($(1)_SOURCES),$$(call interface,$$(src)))
bytelib-$(1)-objects:=$$(foreach src,$$($(1)_SOURCES),$$(call bytecode,$$(src)))
bytelib-$(1)-lib:=$(call bytelib,$(1))

$$(info bytelib-$(1)-lib = $$(bytelib-$(1)-lib))
$$(info bytelib-$(1)-interfaces = $$(bytelib-$(1)-interfaces))
$$(info bytelib-$(1)-objects = $$(bytelib-$(1)-objects))

bytelib-$(1)-ocamlc-options:=$$(module-ocamlc-options) $$($(1)_OCAMLC_FLAGS) \
	$$(foreach file,$$($(lib)_INCLUDE),-I $$(file))

lm-file-ocamlc-options:=$$(bytelib-$(1)-ocamlc-options)
$$(info lm-file-ocamlc-options = $$(lm-file-ocamlc-options))

lm-file-ocamldep-options:=$$(module-ocamlpp-options) $$(module-ocamldep-options)
$$(info lm-file-ocamldep-options = $$(lm-file-ocamldep-options))

ifdef module-uses-objdir
# Use staging directory
bytelib-$(1)-target=$$(module-obj-dir)/$$(bytelib-$(1)-lib)
$$(bytelib-$(1)-target): $$(module-obj-dir) $$(bytelib-$(1)-lib)
	$$(COPY) $$(bytelib-$(1)-interfaces) $$(module-obj-dir)
	$$(COPY) $$(bytelib-$(1)-lib) $$(module-obj-dir)
else
# Don't use staging directory
bytelib-$(1)-target=$$(bytelib-$(1)-lib)
endif

# Build rule for the library.
$$(bytelib-$(1)-lib): $$(bytelib-$(1)-objects)
	$$(OCAMLLINK) $$(OCAMLINCLUDE) -o $$(bytelib-$(1)-lib) $$(bytelib-$(1)-objects)
# Standard build rule.
.PHONY: build-bytelib-$(1)
build-bytelib-$(1): $$(bytelib-$(1)-target)
endef

# build-natcode-template($1): Build native-code objects for $(1) from
# names in $(1)_SOURCES.
define build-natcode-template
natlib_$(1)_objects=$$(foreach src,$$($(1)_SOURCES),$$(call natcode,$$(src)))
$(call natlib,$(1)): 
	$$(OCAMLNATLINK) $$(OCAMLNATLINK_FLAGS) -o $(call natlib, $1) \
		$$(natlib_$(1)_objects)
.PHONY: build-natcode-$(1)
build-natcode-$(1): $(call natlib,$(1))
endef

# build-byteprog-template($1): Build byte-code program for $(1) from
# names in $(1)_SOURCES
define build-byteprog-template
byteprog_$(1)_objects=$$(foreach src,$$($(1)_SOURCES),$$(call bytecode,$$(src)))
$(1): $$(byteprog_$(1)_objects)
	$$(OCAMLC) $$($(1)_OCAMLC_FLAGS) -o $(1) $$(($1)_INCLUDE)\
		$$($(1)_LIBS) $$(byteprog_$(1)_objects)
#
.PHONY: build-byteprog-$(1)
build-byteprog-$(1): $(1)
endef

######
# Use the templates to build everything in Makefile.module
#

###
# Module settings
# 

##
# If LOCAL_X_FLAGS is undefined, use the default.

ifndef LOCAL_OCAMLPP_FLAGS
LOCAL_OCAMLPP_FLAGS:=$(GLOBAL_OCAMLPP_FLAGS) $(MODULE_OCAMLPP_FLAGS)
endif

ifndef LOCAL_OCAMLDEP_FLAGS
LOCAL_OCAMLDEP_FLAGS:=$(GLOBAL_OCAMLDEP_FLAGS) $(MODULE_OCAMLDEP_FLAGS)
endif

ifndef LOCAL_OCAMLC_FLAGS
LOCAL_OCAMLC_FLAGS:=$(GLOBAL_OCAMLC_FLAGS) $(MODULE_OCAMLC_FLAGS)
endif

# module-ocamlpp-options: Module wide ocamlpp flags. 
module-ocamlpp-options=$(LOCAL_OCAMLPP_FLAGS)

# module-ocamldep-options: Module wide ocamldep flags. 
module-ocamldep-options=$(module-ocamlpp-options) $(LOCAL_OCAMLDEP_FLAGS)

# module-ocamlc-options: Module wide ocamlc flags. 
module-ocamlc-options=$(module-ocamlpp-options) $(LOCAL_OCAMLC_FLAGS)

##
# Options to pass to sub-directorys
module-subdir-args=\
	GLOBAL_OCAMLPP_FLAGS=$(LOCAL_OCAMLPP_FLAGS) \
	GLOBAL_OCAMLDEP_FLAGS=$(LOCAL_OCAMLDEP_FLAGS)
	GLOBAL_OCAMLC_FLAGS=$(LOCAL_OCAMLC_FLAGS)

# module-uses-objdir: Defined iff the module uses a staging directory.
# module-obj-dir: The staging directory to use.
ifeq ($(strip $(MODULE_USE_OBJDIR)),yes)
module-uses-objdir=yes
module-obj-dir=$(OBJ_ROOT)
endif

# module-has-subdirs: Defined iff the module has sub-directories.
ifneq ($(strip $(SUBDIRS)),)
module-has-subdirs=yes
endif

# module-sources: All library and program sources, with library sources first
module-sources=$(foreach lib,$(LIBRARIES),$($(lib)_SOURCES)) \
	$(foreach prog,$(PROGRAMS),$($(prog)_SOURCES))

# module-mlsources: All ml sources, with library sources first
module-mlsources=$(foreach src,$(module-sources),$(call mlfile,$(src)))

# module-headers: All headers, with library headers first
module-headers= $(foreach src,$(module-sources),$(call header,$(src)))

# module_interfaces: All headers, with library headers first
module_interfaces=$(foreach source,$(module-sources),$(call interface,$(source)))

$(info module-lib-sources = $(module-lib-sources))
$(info module-prog-sources = $(module-prog-sources))
$(info module_interfaces = $(module_interfaces))
$(info module-headers = $(module-headers))
$(info module-mlsources = $(module-mlsources))

###
# Instantiate the targets
#

##
# Instantiate targets for each sub-directory
$(foreach sub,$(SUBDIRS),\
$(eval $(call subdir-targets-template,$(sub))))

##
# Instantiate bytelib build targets for each target.
$(foreach lib,$(LIBRARIES),\
$(eval $(call build-bytelib-template,$(lib))))

##
# Instantiate build targets for byte-code programs
$(foreach prog,$(PROGRAMS),\
	$(eval $(call build-byteprog-template,$(prog))))

###
# Directories
#

$(module-obj-dir):
	$(MKDIR) $(module-obj-dir)

.PHONY: build-objdir
build-objdir: $(OBJ_ROOT)

#
# Libraries
#

.PHONY: build-headers
build-headers: $(module_interfaces)

.PHONY: build-bytelibs
build-bytelibs: $(module_interfaces) $(foreach lib,$(LIBRARIES),build-bytelib-$(lib) )

.PHONY: build-programs
build-programs: $(module_interfaces) $(foreach prog,$(PROGRAMS),build-byteprog-$(prog) )


###
# Clean up
###

clean: 
	$(foreach subdir, $(SUBDIRS), \
		$(MAKE) -C $(subdir) clean; )
	-$(RM) *.cmo *.cmx *.o *~

libclean: clean
	$(foreach subdir, $(SUBDIRS), \
		$(MAKE) -C $(subdir) libclean; )
	-$(RM) *.cmi *.cma *.cmxa *~

distclean: clean libclean
	$(foreach subdir, $(DOCSUBDIRS), \
		$(MAKE) -C $(subdir) reallyclean; )
	-$(RM) depend

###
# Toplevel targets

.PHONY: build
build: build-objdir build-headers build-bytelibs build-programs

##
# Run the sub-directories.

#ifdef module-has-subdirs
.PHONY: depend-subdirs
depend-subdirs: $(foreach sub,$(SUBDIRS), depend-subdir-$(1))

.PHONY: build-subdirs
build-subdirs: $(foreach sub,$(SUBDIRS), build-subdir-$(1))

.PHONY: install-subdirs
install-subdirs: $(foreach sub,$(SUBDIRS), install-subdir-$(1))

.PHONY: clean-subdirs
clean-subdirs: $(foreach sub,$(SUBDIRS), clean-subdir-$(1))

.PHONY: libclean-subdirs
libclean-subdirs: $(foreach sub,$(SUBDIRS), libclean-subdir-$(1))

.PHONY: distclean-subdirs
distclean-subdirs: $(foreach sub,$(SUBDIRS), distclean-subdir-$(1))
#endif

##
# Dependencies
# Define NODEPEND to prevent using depend
##

depend: $(module-headers) $(module-mlsources)
	-$(OCAMLDEP) $(module-headers) $(module-mlsources) > depend

ifndef NODEPEND
include depend
endif


####
# Variables that should not be exported
unexport module-uses-objdir
unexport module-has-subdirs
