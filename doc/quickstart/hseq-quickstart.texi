\input texinfo  @c -*-texinfo-*-

@c %**start of header
@setfilename hseq-quickstart.info
@settitle HSeq Quick Start
@c %**end of header

@c Local definitions
@include localdefs.texi

@copying
Copyright @copyright{} 2005-2014, Matthew Wahab
@end copying

@titlepage
@title @HSeq{} Quick Start
@author Matthew Wahab <@email{mwb.cde@@gmail.com}>

@page
@vskip 0pt plus lfill
@insertcopying
@end titlepage

@ifnottex
@node Top
@top HSeq Quick Start
@insertcopying
@end ifnottex

@HSeq{} is a tactical theorem prover for a typed, higher order logic
based on the sequent calculus. It is written in OCaml and can be used
interactively through the OCaml toplevel or as a library linked into
an application. This manual assumes that it is used through the OCaml
toplevel.

@HSeq{} is experimental, alpha-quality code that may have soundness bugs.

@chapter Overview

@HSeq{} is a system for constructing theories and trying to prove a
statement in the logic. A logical statement is expressed in @HSeq{} as
a @emph{term} which is constructed from operators and values. Every
term has a @emph{type}, formed from type constructors and constructors
and primitive types. 

For example, the following are terms and types in @HSeq{}:
@example
Terms:
  @code{!x: x = x}
  @code{!f g: (!x: (f x) = (g x)) => f = g}

Types:
  @code{bool}        (The booleans)
  @code{('a, 'b)FUN} (Functions)
  @code{('a -> 'b)}  (Functions)
@end example

A term is a @emph{formula} if it is syntactically well-formed and has
a valid type. A @emph{theorem} is a formula that has been proved to be
true. An @emph{axiom} is a formula that has been declared without
proof to be a true statement. Definitions and declarations can be used
to introduce new constructors for terms or types. A declaration
introduces an uninterpreted identifier, a definition introduces an
identifier as a short-hand for a more complex term.

For example, the following are formulas, theorems and definitons in @HSeq{}:
@example Formulas etc
Formulas:
  @code{!x: (true & x) = x}
  @code{!x y z: (x & y | z) = ((x & y) | (x & z))}
  @code{!(P: bool -> bool): ((P true) & (P false)) => (!(x: bool): P x)}

Theorems:
  @code{|- !t f: (if true then t else f) = t}
  @code{|- !x A: (finite A) => (finite add x A)}
  @code{|- !(A: ('a)set): A = empty | (?(x: 'a): in x A)}

Type definitions:
  @code{('a)set='a -> bool}

Definitions:
  @code{in:  'a -> ('a)set -> bool 
        |- !x A: (in x A) = (A x)}
  @code{compose:  ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
        |- !f g: (compose f g) = (%x: f g x)}
@end example

@section Theories

In @HSeq{}, a @emph{theory} is a record of declarations, definitions
and theorems that provides a context (equivalently, a @emph{scope}) in
which types, terms and proofs can be constructed. A term and or type
is well-formed in a theory iff all constructors and operators used in
term or type are available in the context provided by the theory.

A theory @var{T} can have one or more @emph{parent} theories. All
declarations, definitions and theorems available in the parent of a
theory are also available in the theory @var{T}. All theories have
@code{Main} as a parent, which makes the built-in theories
available. @HSeq{} theories are effectively a module system providing
a means to structure the declarations, definitions and theorems that
make up a logical theory.

For example, the following defines a new theory @code{N}, which
has two different definitions of a function:
@example
begin_theory "N" []

(* Declaration and axiom *)
declare << aexamp : 'a -> 'a -> 'a >>
axiom "aexamp_axiom" << !a b: (aexamp a b) = (if a then b else a) >>

(* Definition *)
define <:def< bexamp x y = if x then y else x >>

end_theory()
@end example

@section Proofs

In @HSeq{}, a proof is made up of a @emph{goal} and one or more
@emph{tactics} which implement the steps of the proof. A goal consists
of the formula to be proved and a set of @emph{sequents}. A sequent is
a sub-goal to be proved and is formed of a set of @emph{assumptions}
and a set of @emph{conclusions}. Initially, a goal has one sequent
which has no assumptions and the formula to be proved as the single
conclusion.

Example:
@example
# goal << !x y: (x = y) => (x => (y & x)) >>;;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
----------------------
[1] !x y: x = y => x => (y & x)
@end example

Tactics implement the inference rules and proof procedures of the
logic.  A goal is manipulated by applying tactics to manipulate and
simplify sequents, possibly introducing new sub-goals that are easier
to prove. Tactics can be combined, using @emph{tacticals}, allowing
complex procedures to be built up from the more basic rules.

Example:
@example
# by (allC ++ allC ++ implC ++ implC);;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
[~1] _x
[~2] _x = _y
----------------------
[1] _y & _x

# by split_tac;;
2 subgoals
(Subgoal 1)
[~1] _x
[~2] _x = _y
----------------------
[1] _y

(Subgoal 2)
[~1] _x
[~2] _x = _y
----------------------
[1] _x

- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
2 subgoals
[~1] _x
[~2] _x = _y
----------------------
[1] _y
@end example

In an interactive proof, the goal is stated first and the tactics
given seperately in a sequence of steps. This makes finding a proof
simpler since it is easier to match the tactics with the sub-goals to
prove.

Example, an interactive proof:
@example
# goal << !x y: (x = y) => (x => (y & x)) >>;;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
----------------------
[1] !x y: x = y => x => (y & x)

# by (allC ++ allC ++ implC ++ implC);;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
[~1] _x
[~2] _x = _y
----------------------
[1] _y & _x

# by ( split_tac ++ replace_tac ++ blast_tac);;
Subgoal solved
- : HSeq.Goals.Proof.t = Goal !x y: x = y => x => (y & x)
                         No subgoals

# qed "t1";;
- : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end example

The command @code{qed @var{n}} stores the theorem under name
@var{n}; it can be retrieved using command @code{thm @var{n}}. For
example, 
@example
# thm "t1";;
- : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end example

An interactive proof is useful for finding the tactics needed to
justify a theorem. Once found, a more compact form, that is faster to
process, can be used to repeat the proof in the script used to build a
theory.

Example, proof for a theory definition:
@example
# (lemma "l1" << !x y: (x = y) => (x => (y & x)) >> 
   [allC;  allC ; implC ; implC ;split_tac ++ (replace_tac ++ blast_tac)]);;
  - : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end example
As before, the command @code{thm "l1"} will retrieve the theorem.

If a theorem doesn't need to be stored permanently, the formula and
tactic need to prove it can combined into a single command
@code{prove}. This is useful for constructing specialized lemmas that
are too specific for general use.

Example, a constructed proof:
@example
# (prove << !x y: (x = y) => (x => (y & x)) >> 
   (allC ++ allC ++ implC ++ implC ++ split_tac ++ replace_tac ++ blast_tac));;
- : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end example

Tactics, including those providing the basic rules of inference, are
functions in OCaml. New tactics can be implemented by function
definition in terms of the existing tactics and tactical.  Functions
making use of @HSeq{} goals and proofs can also be defined.  A
@emph{conversion} is a function that creates a specialized theorem
from a term. Typically, a conversion of term @code{T} generates a
theorem of the form @code{T=true} (or @code{T=false}). A conversion
works by generating a goal trying to construct a proof for the
theorem. If the theorem can't be be proven, the conversion fails.

@chapter Programs

@HSeq{} is built as an extension to the OCaml toplevel (@code{ocaml}).

@strong{@code{hseq @var{options}}} starts the interactive interpreter
and makes the @HSeq{} extensions available @var{options} are the
options to pass to the OCaml system.

@strong{@code{hseqb @var{options} @var{file}}} executes @var{file} as a script.
@strong{@code{hseqc @var{options} @var{file}}} compiles the OCaml file
@var{file} against the @HSeq{} headers and libraries.

@section Toplevel

The usual way to interact with @HSeq{} is through the toplevel
system. This has a number of functions to help 


@strong{@code{reset()}} resets the @HSeq{} system to its initial state.


@subsection Quotations

@HSeq{} terms, types and definitions can be used in OCaml expressions
using quotations of the form @code{<< .. >>}. The accepted forms are:
@table @code
@item @code{<< str >>}
parses @var{str} as a term.
@item @code{<<: str >>}
parses @var{str}  as a type.
@item @code{<:def< str >>}
parses @var{str} as a term definition
@item @code{<:def<: str >>}
parses @var{str} as a type definition or declaration.
@end table


@chapter Types

A type in the logic has OCaml type @code{Basic.gtype} and is a
@emph{type variable}, a @emph{type constructor} or a @emph{weak type
variable}.

The standard syntax of the types is:
@table @code
@item @code{'a}
 a type variable of name @emph{a}.  
@item @code{'_a} 
 a weak type variable of name @emph{a}.
@item @code{(t1, @dots{}, t@var{n})f}
a constructed type, with constructor identifier @emph{f} and @var{n}
arguments. 
@item @code{f}
a constructed type, with constructor identifier @emph{f} and no arguments. 
@end table

Some types may also have a specialized form that can be used as an
alternative to the standard syntax.

If the identifier @emph{f} is in the form @code{@var{T}.@var{n}} then
it is the constructor named @var{n} declared in the theory named
@var{T}. If @emph{f} is @code{@var{n}}, the scope of the type is
searched for a definition or declaration of @var{n}.

A weak type variable is a type variable which cannot be bound to a
type variable. It can bind only with another weak type variables or
with a a type constructor. Weak type variables occur only in
sequents. If a weak type variable @var{v} is bound to a type @var{t}
in a sequent, all instances of @var{v} are bound to @var{t}. Weak type
variables are treated as ordinary type variables by the parser.

The standard types are: 
@table @code
@item @code{bool}
the booleans
@item @code{'a -> 'b}
functions from @code{'a} to @code{'b}.
@item @code{('a)set} 
sets of @code{'a} 
@item @code{'a * 'b}
the product of @code{'a} and @code{'b}.
@end table

@chapter Terms

A term has OCaml type @code{Basic.term} and is an @emph{identifier}, a
@emph{free variable}, a @emph{bound variable}, a @emph{binding term}
or a function application. Terms have types and a @emph{formula} is a
well-formed term that is correctly typed in some @emph{scope}.

The core terms and their syntax are:
@table @code
@item @strong{@code{true}}, @strong{@code{false}}
The boolean true and false.
@item @strong{@code{f a}}
Function application. 
@item @code{@strong{~}a}, @code{@strong{not} a}
The negation of term @code{a}.
@item @code{a @strong{&} b}, @code{a @strong{and} b}
The conjunction of terms @code{a} and @code{b}
@item @code{a @strong{|} b}, @code{a @strong{or} b}
The disjunction of terms @code{a} and @code{b}
@item @code{a @strong{=>} b}, @code{a @strong{implies} b}
Implication for terms @code{a} and @code{b}
@item @code{a @strong{iff} b}
The boolean of terms @code{a} and @code{b}.
@item @code{a @strong{=} b}
The equality of terms @code{a} and @code{b}.
@item @code{(@var{t}@strong{:}@var{ty})}.
Specifies that term @var{t} has type @var{ty}.
@item @code{@strong{@@} x@strong{:} F}
The choice operator (i.e. some @code{x} for which @code{F} is true)
@end table

The operators have the usual priorities, brackets can be used as
normal. Function application has lower priority than other operators
and the equality operator has higher priority than boolean equivalent.

A term identifier @var{f} is either in the form @code{@var{T}.@var{n}}
or @var{n}. For @code{@var{T}.@var{n}}, the identifier is the name
@var{n} declared in the theory named @var{T}. If @var{f} is @var{n},
the scope of the term is searched for a list of theories in which
@var{n} is defined or declared. The name @var{n} is resolved by
choosing the first declaration or definition which matches the type of
@var{f}.

Binding terms are lambda-abstractions, the epsilon and the universal
and existential quantifiers. A binding term (with some symbol
@var{SYM}) is written @code{@var{SYM} x : F} and binds variable
@code{x} in term @code{F}. The binding generalizes to a list of
variables: @code{@var{SYM} x1 x2 @dots{} xn : F} binds variables
@code{x1}, @code{x2}, @dots{}, @code{xn} in term @code{F}.

The binding terms are:
@table @code
@item @code{@strong{%} x@strong{:} F}
A lambda term.
@item @code{@strong{!} x@strong{:} F}
Universal quantification.
@item @code{@strong{?} x@strong{:} F}
Existential quantification. 
@item @code{@strong{?!} x@strong{:} F}.
Unique existential binding (i.e. there exists one @code{x} such that
@code{F} is true).
@end table

A variable @code{x} in a binding can be typed in which case it is
written with brackets as @code{(x: ty)}.  For example
@example 
@code{! x (y: bool) z : ?  (A:('a)set): (y and z) | (x = A)}.
@end example

@chapter Theories

A @emph{theory} is a set of declarations, definitions and theorems. A
theory provides the @emph{scope} in which formulas are constructed.

A theory @var{T} is built from a @emph{script file} named
@code{@var{T}Script.ml}. It is saved to a @emph{theory file} named
@code{@var{T}.tho}.      

A theory can depend on other theories (its @emph{parents}). When a
theory is built or loaded from file, its parents are also loaded. If
the parent of a theory does not have a theory file, it is rebuilt from
its script file. All theories must be younger than the theories they
depend on and theories are automatically rebuilt if necessary.

A theory is either @emph{closed} or @emph{writable}. A closed theory
can be the parent of other theories but cannot be modified. A writable
theory can be modified but cannot be used as the parent of another
theory.

The main theory for @HSeq{} is called @code{Main} and is automatically
set as a parent for each new theory.

@section Theory Functions

@table @code
@item @strong{@code{begin_theory @var{n} [@var{p1}; @dots{}; @var{pn}]}}
Begins a theory named @var{n} with parents @var{p1}, @dots{},
@var{pn}.

@item @strong{@code{end_theory()}}
Ends the currently open theory, marking it as closed and saving it to
a theory file.

@item @strong{@code{add_file @var{n}}}
Marks file @var{n} as a library to be loaded when the theory is
loaded. If @var{n} ends with suffix @code{.ml}, it is loaded using
@code{#use}. If @var{n} ends with suffix @code{.cmi} or @code{.cmo} it
is loaded with @code{#load}.

@item @strong{@code{compile @var{path} @var{n}}}
Compiles file @var{n} with the standard @HSeq{} libraries. @var{path}
is the list of additional include directories to use.
@end table

@subsection Query Functions

@table @code
@item @strong{@code{theory @var{x}}}
Displays theory @var{n}. If @var{x} is the empty string (@code{""}),
the current theory is displayed.

@item @strong{@code{defn @var{x}}}
Gets the defining theorem for term @var{x}. If @var{x} is in the form
@code{@var{T}.@var{n}}, it identifies term @var{n} from theory
@var{T}, otherwise the scope is searched for a definition of @var{x}.

@item @strong{@code{thm @var{x}}} 
Get the theorem named @var{x}. Note that axioms are theorems. If
@var{x} is in the form @code{@var{T}.@var{n}}, it identifies theorem
@var{n} from theory @var{T}, otherwise the scope is searched for a
theorem named @var{x}.

@item @strong{@code{scope()}}
Get the current scope. 

@item @strong{@code{goal_scope()}}
Get the scope of the current goal (in an interactive proof).
@end table

@section Declarations and Definitions

@table @code
@item @strong{@code{declare << @var{D} >>}}
Declares a term. @var{D} should be in the form @code{@var{n}:@var{ty}}
where @var{n} is the identifier and @var{ty} the type. Note that
@code{declare} uses the term quotation parser (@code{<< @dots{} >>})
not the definition quotation parser.

Example:
@example
@code{declare <:def< and:(bool -> bool -> bool) >>}.
@end example

@item @strong{@code{define <:def< @var{D} >>}} 
Defines a term. @var{D} must be in the form @code{@var{n} @var{a1}
@dots{} @var{an} = @var{T}} where @var{n} is the identifier being
defined, @var{a1} @dots{}  @var{an} are the parameters and @var{T} the
body of the definition.

Example:
@example
@code{define <:def< or x y = (not (not x) and (not y)) >>}.
@end example

@item @strong{@code{typedef <:def<: @var{D} >>}} 
Declares or defines a type constructor.  @code{typedef <:def<:
@var{ty} >>} declares the new type @var{ty} constructor. @code{typedef
<:def<: @var{ty1} = @var{ty2} >>} declares @var{ty1} to be an alias
for type @var{ty2}.

Example:
@example
(declaration) @code{typedef <:def<: bool >>}
(aliasing)    @code{typedef <:def<: ('a)set = ('a -> bool)>>}.
@end example

@item @strong{@code{typedef ~thm:@var{T} <:def<: @var{ty1} = @var{ty2}:@var{pred} >>}} 
Defines @var{ty1} as the subtype of type @var{ty2} containing elements
which satisfy term @var{pred} (which should have type @code{@var{ty2}
-> bool}). Existence theorem @var{T} must be in the form @code{?x:
@var{pred} x}.

Example
@example 
@code{typedef <:def<: ('a, 'b)PAIR = ('a -> 'b -> boo): is_pair>>}.
@end example

@end table

The declaration and definition commands take an optional argument
named @code{?pp} to specify printer-parser information. This sets the
precedence, fixity and the symbol to use for the identifier or
constructor.

THe fixity values are @strong{@code{prefix}}, @strong{@code{infixl}}
(infix, left associative), @strong{@code{infixr}} (infix, right
associative), @strong{@code{infixn}} (infix, non-associative) and
@strong{@code{suffix}}.

@section Axioms and Theorems

@table @code
@item @strong{@code{axiom @var{T}}} 
Declares term @var{T} as an axiom. 

@item @strong{@code{theorem @var{T} [@var{tac1}; @dots{}; @var{tacn}]}}
Adds term @var{T} as a theorem using the list of @emph{tactics}
@var{tac1} @dots{}  @var{tacn} as a proof. A goal is constructed from
term @var{T} and each tactic in the list is applied, in order, to the
first subgoal.

The list of tactics used by @code{theorem} is an unstructured proof:
the tactics are always applied to the first sub-goal, as they are in
interactive proofs. This makes it easier to transfer interactive
proofs to a batch proof.

@end table

@code{axiom} and @code{theorem} take the optional argument @code{?simp}
which marks the axiom/theorem for use as a simplification rule.

@chapter Interactive Proofs

In sequent @code{@var{asm} |- @var{concl}}, @var{asm} is the list of
assumptions and @var{concl} is the list of conclusions. The
assumptions and the conclusions are the @emph{formulas} of the
sequent. The terms sequent and sub-goal will be used interchangeably.

When a sequent is displayed, the assumptions are printed before the
conclusions, separated by a line.  Each assumption is printed with a
negative integer, starting with @code{-1} and each assumption is
printed with a positive integer, starting with @code{1}. The
@emph{first assumption} is numbered @code{-1}, the @emph{first
conclusion} is numbered @code{1}.

Each sequent formula can be identified by a unique @emph{label}. A
string @var{str} can be set as the label for a formula, in which case
the label is referred by the OCaml expression @code{!$
@var{str}}. When a string is set as the label of a sequent formula, it
replaces the integer normally displayed with the formula.

@table @code
@item @strong{@code{goal @var{t}}} 
Set term @var{t} as the goal in an interactive proof.

@item @strong{@code{by @var{tac}}} 
Applies tactic @var{tac} to the current subgoal.

@item @strong{@code{undo()}} 
Drops the result of the last @code{by} command.

@item @strong{@code{top()}} 
Displays the current sub-goal.

@item @strong{@code{prove @var{t} @var{tac}}}
Proves the theorem built from term @var{t} using tactic @var{tac},
failing if the tactic fails.
@end table

@section Tactics

In @HSeq{}, a tactic is a fundamental type, defined in module
@code{HSeq.Logic}. These are defined as the type @code{node ->
branch}, where @code{node} is the goal on which a tactic operates and
@code{branch} the resulting sub-goals.

For normal use, the tactics of type @code{HSeq.Tactics.tactic =
Context.t -> Logic.node -> Logic.branch} are more useful. These take a
theory context, making it easier to use definitions and theorems in a
proof.

Module @code{HSeq.Tactics} also defines @emph{data-tactics} as
@code{('a) data_tactic = Context.t -> Logic.node -> ('a *
Logic.branch)}. These are tactics that can extract data from a goal
and are typically used when implementing procedures to pass data from
one tactic to another.

Tactics are generally named with suffix '_tac'. Tactics ending with a
'A' act on the assumptions of a sub-goal. Tactics ending with 'C' act
on the conclusions. Optional arguments are generally named @code{?a} for
an assumption, @code{?c} for a conclusion, @code{?f} for an assumption or
conclusion and @code{?inst} for a list of terms.

@table @code

@item @strong{@code{conjA}}, @strong{@code{conjC}}
@itemx @strong{@code{disjA}}, @strong{@code{disjC}}
@itemx @strong{@code{implA}}, @strong{@code{implC}},
@itemx @strong{@code{negA}}, @strong{@code{negC}}
@itemx @strong{@code{existA}}, @strong{@code{existC}}
@itemx @strong{@code{allA}}, @strong{@code{allC}}
Eliminate conjunctions, disjunctions, implications, negation and
existential and universal quantifiers.

For example,
@table @code
@item conjA
reduces @code{[@var{A} and @var{B}, @var{asms} |- @var{concls}]}
to
@code{[@var{A}, @var{B}, @var{asms} |- @var{concls}]}

@item conjC
splits @code{[@var{asms} |- @var{A} and @var{B}, @var{concls}]}
to
@code{[@var{asms} |- @var{A}, @var{concls}]}
and @code{[@var{asms} |- @var{B}, @var{concls}]}
@end table

@item @strong{@code{betaA}}, @strong{@code{betaC}} and @strong{@code{beta_tac}} 
Beta reduce formulas.

For example, 
@table @code
@item betaA
reduces @code{[(% x: (f x)) true, @var{asms} |- @var{concls}]}
to
@code{[(f true), @var{asms} |- @var{concls}]}
@end table

@item @strong{@code{basic}} 
Solves sub-goals of the form @code{[@var{F}, @var{asm} |- @var{F},
@var{concl}]} (a formula appearing in both assumptions and
conclusions).

@item @strong{@code{trivial}} 
Solves subgoals in which @code{true} appears in the conclusions or
@code{false} appears in the assumptions.

@item @strong{@code{eq_tac}} 
Solves subgoals in which term @code{x=x} appears in the conclusions.

@item @strong{@code{equals_tac}} 
Replaces equality (=) between booleans with boolean equivalence (iff).

@item @strong{@code{iffA}} and @strong{@code{iffC}} 
Eliminate boolean equivalence.

@item @strong{@code{instA}}, @strong{@code{instC}}, @strong{@code{inst_tac}} 
Instantiate assumptions and conclusions with a given list of
terms. 

@item @strong{@code{specA}}, @strong{@code{specC}}, @strong{@code{spec_tac}} 
Specialize assumptions and conclusions.

@item @strong{@code{cut @var{thm}}} 
Introduces theorem @var{thm} as an assumption. The optional argument
@code{?inst} can be used to instantiate the assumption with values.

@item @strong{@code{flatten_tac}} 
Eliminates basic boolean operators without splitting the sub-goal.

@item @strong{@code{split_tac}} 
Eliminates the basic boolean operators, splitting the sub-goal.

@item @strong{@code{scatter_tac}} 
Combines @code{flatten_tac} and @code{split_tac}.

@item @strong{@code{blast_tac}} 
Applies @code{scatter_tac} followed by @code{basic}.

@end table

The order of assumptions and conclusions can be significant for
tactics which search for a formula.  

@table @code
@item @strong{@code{liftA @var{l}}} and @strong{@code{liftC @var{l}}} 
Lift the assumption or conclusion labelled @var{l} to the front of the
list of assumptions or conclusions.

@item @strong{@code{copyA @var{l}}} and @strong{@code{copyC @var{l}}} 
Copy the assumption or conclusion with label @var{l}.

@item @strong{@code{deleteA @var{l}}} and @strong{@code{deleteC @var{l}}}
Delete the assumption or conclusion labelled @var{l}.

@item @strong{@code{match_asm @var{t} tac}} and @strong{@code{match_concl @var{t} @var{tac}}}
Search the sequent for an assumption or conclusion matching the term
@var{t}, applying @code{@var{tac} @var{l}} where @var{l} is the label
of the matched formula. Free variables in @var{t} match sub-terms in
the assumptions/conclusions.

Example:
@example
@samp{match_asm << !x y z: A => C >> liftA}.
@end example

@item @strong{@code{nameA @var{str} @var{l}}} and @strong{@code{nameC @var{str} @var{l}}}
Set string @var{str} as the label of the assumption or conclusion with
label @var{l}. These should be used in conjunction with
@code{match_asm} and @code{match_concl}.
@end table

Some other useful tactics include:
@table @code

@item @strong{@code{unify_tac}}
Try to unify an assumption with a conclusion. Fails if no assumption
can be unified with any conclusion. The assumption and conclusion can
optionally be given.

@item @strong{@code{back_tac}}
Matches a possibly quantified assumption of the from @code{a => c}
with a conclusion of the form @code{c}, replacing the conclusion with
@code{a}.

@item @strong{@code{mp_tac}}
Matches a possibly quantified assumption of the from @code{a => c}
with an assumption of the form @code{a}, replacing it with assumption
@code{c}.

@item @strong{@code{cut_back_tac}} and @strong{@code{cut_mp_tac}} 
Operate with theorems of the form @code{a=>c} (which may be
universally quantified). The conclusion @code{c} is unified with an
assumption and replaced with the assumption @code{a}.

@item @strong{@code{show @var{t} @var{tac}}} 
Introduces term @var{t} as an assumption, using tactic @var{tac} to
prove the truth of @var{t}.

@item @strong{@code{cases_tac @var{t}}} 
Introduces a case split on the truth of term @var{t}.

@item @strong{@code{case_of @var{t}}} 
Introduces a case split on the possible values of term @var{t}.

@item @strong{@code{induct_tac @var{thm}}} 
Begins a proof by induction on a conclusion of the form @code{! x .. y
: R => A}.

@item @strong{@code{induct_on @var{n}}} 
Begins a proof by induction on the quantified variable named @var{n},
failing if there is no such variable in the conclusions or no
appropriate induction theorem. The induction theorem used depends on
the type of variable @var{n}.
@end table

@section Rewriting and Simplification

Rewriting works on rewrite rules of the form @code{! @var{x}:
@var{A}(@var{x}) => @var{C}(@var{x})}. Rewrites rules can be theorems
or be assumptions in a sequent, e.g. introduced using @code{cut}.

Some rewriting tactics take an optional argument @code{?dir} to specify
the rewriting direction. The possible values are
@strong{@code{rightleft}} or @strong{@code{leftright}}.

@table @code
@item @strong{@code{rewriteA_tac}}, @strong{@code{rewriteC_tac}} and @strong{@code{rewrite_tac}} 
Rewrite tactics for assumptions, conclusions and sequent formulas with
rewrite rules provided as a list of theorems.

@item @strong{@code{once_rewriteA_tac}}, @strong{@code{once_rewriteC_tac}} and @strong{@code{once_rewrite_tac}}
Apply a rewrite rule once in the assumption, conclusion or anywhere in
the sequent.

@item @strong{@code{replace_tac}} and @strong{@code{once_replace_tac}}
Rewrite formulas with rules from the assumptions. 

@item @strong{@code{unfold @var{n}}} 
Unfold the definition of term @var{n}.
@end table


The main simplification tactics are @code{simpA_tac},
@code{simpC_tac}, @code{simp_all_tac} and @code{simp_tac}.

@table @code
@item @strong{@code{simpA_tac}} 
Simplifies the assumptions, starting with the first.

@item @strong{@code{simpC_tac}} 
Simplifies the conclusions, starting with the last.

@item @strong{@code{simp_all_tac}} 
Simplifies the assumptions, starting with the first, and then the
conclusions, starting with the last.

@item @strong{@code{simp_tac}}
Simplify a sequent formula, chosen from an optional label. If the
label is given then @code{simp_tac} is either @code{simpC_tac} or
@code{simpA_tac}, otherwise it is @code{simpC_tac}.
@end table

The simplification tactics use the standard simplification rules,
obtained by calling @strong{@code{std_ss()}}. The simplification
tactics ending with @code{_tac} also take a list of theorems to use as
additional simplification rules.

Tactics @strong{@code{simpA}}, @strong{@code{simpC}},
@strong{@code{simp_all}} and @strong{@code{simp}} are short-hand for
the simplification tactics with no additional rules (@code{simp =
simp_tac []}).

@section Tacticals

@table @code
@item @strong{@code{skip}} 
The tactic that does nothing and always succeeds.

@item @strong{@code{fail}}
The tactic that does nothing and always fails.

@item @strong{@code{seq[@var{tac_1}; @var{tac_2}; @dots{}; @var{tac_n}]}}
THe @strong{sequential composition} of tactics. The tactics are
applied in sequence starting with @var{tac_1} and each tactic
@var{tac_(i+1)} is applied to all the sub-goals generated by
@var{tac_i}. The sequence continues until all tactics have been
applied, the goal is solved or a tactic fails.

@strong{@code{@var{tac_1}++@var{tac_2}}} is shorthand for
@code{seq[@var{tac_1}; @var{tac_2}]}.

@item @strong{@code{alt[@var{tac_1}; @var{tac_2}; @dots{}; @var{tac_n}]}}
Alternation between tactics. Each tactic is tried in sequence,
starting with @var{tac_1}, until one of the tactics succeeds. The
alternation fails if all the tactics fail.

@strong{@code{@var{tac_1}//@var{tac_2}}} is shorthand for
@code{alt[@var{tac_1}; @var{tac_2}]}.

@item @strong{@code{@var{tac} -- [@var{tac_1}; @dots{}; @var{tac_n}]}}
The @strong{branching} tactical. First applies tactic @var{tac} then
each tactic @var{tac_i} is applied to the @var{i}'th resulting
sub-goal. All sub-goals are then combined (in the order they were
generated) to form the final list of sub-goals. If there are more
sub-goals than tactics, the extra sub-goals are added to the end of
the final list (as if the list of tactics was padded with
@code{skip}). If there are more tactics than sub-goals, the extra
tactics are ignored.

@item @strong{@code{repeat @var{tac}}}
Repetition. Apply @var{tac} at least once then repeat until it fails
or there are no more subgoals.

@item @strong{@code{cond @var{pred} @var{tac_1} @var{tac_2}}}
Conditional. Apply predicate @var{pred} to a goal, if the result is
@code{true} then apply @var{tac_1} to the goal otherwise apply
@var{tac_2}.

@strong{@code{@var{pred} --> @var{tac}}} is shorthand for
@code{cond @var{pred} @var{tac} @code{skip}}.

@end table

@c
@c End of document
@c

@bye
