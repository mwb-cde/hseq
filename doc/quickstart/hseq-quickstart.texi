\input texinfo  @c -*-texinfo-*-

@c %**start of header
@setfilename hseq-quickstart.info
@settitle HSeq Quick Start
@c %**end of header

@c Local definitions
@include localdefs.texi

@copying
Copyright @copyright{} 2005-2014, Matthew Wahab
@end copying

@titlepage
@title @HSeq{} Quick Start
@author Matthew Wahab <@email{mwb.cde@@gmail.com}>

@page
@vskip 0pt plus lfill
@insertcopying
@end titlepage

@ifnottex
@node Top
@top HSeq Quick Start
@insertcopying
@end ifnottex

@HSeq{} is a tactical theorem prover for a typed, higher order logic
based on the sequent calculus. It is written in OCaml and can be used
interactively through the OCaml toplevel or as a library linked into
an application. 

Note that @HSeq{} is experimental, alpha-quality code that may have
soundness bugs.

@chapter Programs

@HSeq{} is built as an extension to the OCaml toplevel (@code{ocaml}).

@strong{@code{hseq @var{options}}} starts the interactive interpreter
and makes the @HSeq{} extensions available @var{options} are the
options to pass to the OCaml system.

@strong{@code{hseqb @var{options} @var{file}}} executes @var{file} as a script.
@strong{@code{hseqc @var{options} @var{file}}} compiles the OCaml file
@var{file} against the @HSeq{} headers and libraries.

@section Toplevel

The usual way to interact with @HSeq{} is through the toplevel
system. 

@table @code
@item @code{@strong{init()}}
@itemx @code{@strong{reset()}}
Resets the @HSeq{} system to its initial state.

@item @code{@strong{compile} @var{dirs} @var{f}}
Compile file @var{f} against the @HSeq{} headers and libraries, with
the list of directories @var{dirs} added to headers search path.
@end table

@chapter Overview

@HSeq{} is a system for constructing theories and for trying to prove
statements in the logic. A logical statement is expressed in @HSeq{}
as a @emph{term} which is constructed from operators and values. Every
term has a @emph{type}, formed from type constructors and constructors
and primitive types.

@example
For example, the following are terms and types in @HSeq{}:

Terms:
  @code{!x: x = x}
  @code{!f g: (!x: (f x) = (g x)) => f = g}

Types:
  @code{bool}        (The booleans)
  @code{('a, 'b)FUN} (Functions)
  @code{('a -> 'b)}  (Functions)
@end example

A term is a @emph{formula} if it is syntactically well-formed and has
a valid type. A @emph{theorem} is a formula that has been proved to be
true. An @emph{axiom} is a formula that has been declared without
proof to be a true statement. Definitions and declarations can be used
to introduce new constructors for terms or types. A declaration
introduces an uninterpreted identifier, a definition introduces an
identifier as a short-hand for a more complex term.

@example
For example, the following are formulas, theorems and definitons in @HSeq{}:
Formulas:
  @code{!x: (true & x) = x}
  @code{!x y z: (x & y | z) = ((x & y) | (x & z))}
  @code{!(P: bool -> bool): ((P true) & (P false)) => (!(x: bool): P x)}

Theorems:
  @code{|- !t f: (if true then t else f) = t}
  @code{|- !x A: (finite A) => (finite add x A)}
  @code{|- !(A: ('a)set): A = empty | (?(x: 'a): in x A)}

Type definitions:
  @code{('a)set='a -> bool}

Definitions:
  @code{in:  'a -> ('a)set -> bool 
        |- !x A: (in x A) = (A x)}
  @code{compose:  ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
        |- !f g: (compose f g) = (%x: f g x)}
@end example

@section Theories

In @HSeq{}, a @emph{theory} is a record of declarations, definitions
and theorems that provides a context (equivalently, a @emph{scope}) in
which types, terms and proofs can be constructed. A term and or type
is well-formed in a theory iff all constructors and operators used in
term or type are available in the context provided by the theory.

A theory @var{T} can have one or more @emph{parent} theories. All
declarations, definitions and theorems available in the parent of a
theory are also available in the theory @var{T}. All theories have
@code{Main} as a parent, which makes the built-in theories
available. @HSeq{} theories are effectively a module system providing
a means to structure the declarations, definitions and theorems that
make up a logical theory.

@example
For example, the following defines a new theory @code{N}, which
has two different definitions of a function:
@verbatim
begin_theory "N" []

(* Declaration and axiom *)
declare << aexamp : 'a -> 'a -> 'a >>
axiom "aexamp_axiom" << !a b: (aexamp a b) = (if a then b else a) >>

(* Definition *)
define <:def< bexamp x y = if x then y else x >>

end_theory()
@end verbatim
@end example

Each item named @var{n} in a theory @var{T} can be accessed using the
identifier @code{@var{T}.@var{n}}. A short form of the identifer,
@var{n}, can also be used. This searches the module and then the all
imported modules for the item with name @var{n}.

@section Proofs

In @HSeq{}, a proof is made up of a @emph{goal} and one or more
@emph{tactics} which implement the steps of the proof. A goal consists
of the formula to be proved and a set of @emph{sequents}. A sequent is
a sub-goal to be proved and is formed of a set of @emph{assumptions}
and a set of @emph{conclusions}. 

Sequents are displayed with the goal to prove, the number of subgoals
still to prove and then the asssumptions above the conclusions.
@example
Goal @var{goal}
@var{n} subgoal(s)
[~1] @var{assumption}
[~2] @var{assumption}
...
----------------------
[1] @var{conclusion}
[2] @var{conclusion}
...
@end example

For brevity, a sequent with assumptions @var{asms} and conclusions
@var{concls} will sometimes be written @code{[@var{asms} |-
@var{concls}]}. The assumptions and conclusions are the
@emph{formulas} of the sequent.

Initially, a goal has one sequent which has no assumptions and the
formula to be proved as the single conclusion.

@example
Example:
@verbatim
# goal << !x y: (x = y) => (x => (y & x)) >>;;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
----------------------
[1] !x y: x = y => x => (y & x)
@end verbatim
@end example

Tactics are OCaml functions that implement the inference rules and
proof procedures of the logic. A goal is manipulated by applying a
tactic to the current sequent, possibly introducing new sub-goals that
are easier to prove. Tactics can be combined, using @emph{tacticals},
allowing complex procedures to be built up from more basic rules.

@example
Example, continuing the proof started in the previous example:
@verbatim
# by (allC ++ allC ++ implC ++ implC);;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
[~1] _x
[~2] _x = _y
----------------------
[1] _y & _x

# by split_tac;;
2 subgoals
(Subgoal 1)
[~1] _x
[~2] _x = _y
----------------------
[1] _y

(Subgoal 2)
[~1] _x
[~2] _x = _y
----------------------
[1] _x

- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
2 subgoals
[~1] _x
[~2] _x = _y
----------------------
[1] _y
@end verbatim
@end example

Each sequent formula can be uniquely identified by the number assigned
to it when the sequent is displayed. Assumptions are assigned negative
numbers, conclusions are assigned positive numbers. These identifiers
can be passed to tactics to specify the formulas that the tactic
should operate on. 

@example
In the sequent
@verbatim
[~1] _x
[~2] _x = _y
----------------------
[1] _y & _x
@end verbatim
The assumptions are identified by numbers @code{~1} and @code{~2} and
the conclusion has number @code{1}.
@end example

The operator @code{(!! @var{n})} (or @code{fnum @var{n}}) constructs
the identifier for formula @var{n}. Arbitrary strings can be assigned
as an identifier for a formula, using tactic @code{name_tac} but no
attempt is made to keep the string identifiers unique.

@example
@verbatim
# by (name_tac "asm_a" (!! -2));;
- : HSeq.Goals.Proof.t =
Goal !x y: (x & x = y) => (y & x)
1 subgoal
[~1] _x
[asm_a] _x = _y
----------------------
[1] _y & _x

# by (name_tac "c2" (!! 1));;
- : HSeq.Goals.Proof.t =
Goal !x y: (x & x = y) => (y & x)
1 subgoal
[~1] _x
[asm_a] _x = _y
----------------------
[c2] _y & _x

@end verbatim
@end example

In an interactive proof, the goal is stated first and the tactics
given seperately in a sequence of steps. This makes finding a proof
simpler since it is easier to match the tactics with the sub-goals to
prove.

@example
An example of an interactive proof:
@verbatim
# goal << !x y: (x = y) => (x => (y & x)) >>;;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
----------------------
[1] !x y: x = y => x => (y & x)

# by (allC ++ allC ++ implC ++ implC);;
- : HSeq.Goals.Proof.t =
Goal !x y: x = y => x => (y & x)
1 subgoal
[~1] _x
[~2] _x = _y
----------------------
[1] _y & _x

# by ( split_tac ++ replace_tac ++ blast_tac);;
Subgoal solved
- : HSeq.Goals.Proof.t = Goal !x y: x = y => x => (y & x)
                         No subgoals

# qed "t1";;
- : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end verbatim
@end example

The command @code{qed @var{n}} stores the theorem under name
@var{n}; it can be retrieved using command @code{thm @var{n}}. 
@example
For example,
@verbatim
# thm "t1";;
- : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end verbatim
@end example

An interactive proof is useful for finding the tactics needed to
justify a theorem. Once found, a more compact form, that is faster to
process, can be used to repeat the proof in the script used to build a
theory.

@example
Example, proof for a theory definition:
@verbatim
# (lemma "l1" << !x y: (x = y) => (x => (y & x)) >> 
   [allC;  allC ; implC ; implC ;split_tac ++ (replace_tac ++ blast_tac)]);;
  - : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end verbatim
@end example
As before, the command @code{thm "l1"} will retrieve the theorem.

If a theorem doesn't need to be stored permanently, the formula and
tactic need to prove it can combined into a single command
@code{prove}. This is useful for constructing specialized lemmas that
are too specific for general use.

@example
Example, a constructed proof:
@verbatim
# (prove << !x y: (x = y) => (x => (y & x)) >> 
   (allC ++ allC ++ implC ++ implC ++ split_tac ++ replace_tac ++ blast_tac));;
- : HSeq.Logic.thm = |- !x y: x = y => x => (y & x)
@end verbatim
@end example

A @emph{conversion} is a function that creates a specialized theorem
from a term. Typically, a conversion of term @code{T} generates a
theorem of the form @code{T=true} (or @code{T=false}). A conversion
works by generating a goal trying to construct a proof for the
theorem. If the theorem can't be be proven, the conversion fails.

@chapter Parsers and Quotations

@HSeq{} Types and terms are read through OCaml parsers and through the
quotation system. The main @HSeq{} syntactic forms are identifiers,
terms, types and definitions.

The main parse functions are:
@table @code

@item @code{@strong{read} @var{str}}
@itemx @code{<< @var{str} >>}
Parses @var{str} as a term.

@item @code{@strong{read_type} @var{str}}
@itemx @code{<< : @var{str} >>}
Parses @var{str} as a type. Note that the quotation must have a space
(' ') after the opening @code{<<} quote.

@item @code{@strong{read_defn} @var{str}}
@itemx @code{<:def< @var{str} >>}
Parses @var{str} as a term definition

@item @code{@strong{read_type_defn} @var{str}}
@itemx @code{<:def< : @var{str} >>}
Parses @var{str} as a type definition or declaration.

@item @code{@strong{read_unchecked} @var{str}}
Parses @var{str} as a term without checking that the term is valid.
@end table

@example
Terms: 
@code{<< ! x: (not x) or x>>} (excluded_middle)
@code{<< ! t f: (if true then t else f) = t >>}
@code{read "! t f: (if true then t else f) = t"}

Types:
@code{<< :bool >>}
@code{read_type "bool -> bool"}

Term definition:
@code{<:def< compose f g = (%x : f (g x)) >>} (function composition)

Type definition:
@code{<:def<: ('a, 'b)PAIR = ('a -> 'b -> bool): is_pair >>}

@end example

@chapter @HSeq{} Types

A type in the logic has OCaml type @code{Basic.gtype} and is a
@emph{type variable}, a @emph{type constructor} or a @emph{weak type
variable}.

The standard syntax for types is:
@table @code
@item @code{'a}
a type variable of name @emph{a}.  
@item @code{'_a} 
a weak type variable of name @emph{a}.
@item @code{(t1, @dots{}, t@var{n})f}
a constructed type, with constructor @strong{@emph{identifier}} @var{f} and
@var{n} arguments.
@item @code{f}
a constructed type, with constructor identifier @emph{f} and no arguments. 
@end table

A type can have a specialized syntax, in addition to the standard
form. For example, the type of functions has the standard form
@code{FUN('a, 'b)} but is normally written in its specialized form
@code{'a -> 'b}.

The core types are: 
@table @code
@item @strong{@code{bool}}
The booleans.
@item @strong{@code{'a -> 'b}}
Functions from @code{'a} to @code{'b}.
@item @strong{@code{('a)set}}
Sets of @strong{@code{'a}}
@item @strong{@code{'a * 'b}}
The product of @code{'a} and @code{'b}.
@end table

A weak type variable is a type variable can bind only with another
weak type variable or with a a type constructor. Weak type variables
occur only in sequents. If a weak type variable @var{v} is bound to a
type @var{t} in a sequent, all instances of @var{v} are bound to
@var{t}. Weak type variables are treated as ordinary type variables by
the parser.

@chapter @HSeq{} Terms

A term has OCaml type @code{Basic.term} and is an @emph{identifier}, a
@emph{free variable}, a @emph{bound variable}, a @emph{binding term}
or a function application. Terms have types and a @emph{formula} is a
well-formed term that is correctly typed in some @emph{scope}.

The core terms and their syntax are:
@table @code
@item @strong{@code{true}}
@itemx @strong{@code{false}}
The boolean true and false.
@item @strong{@code{f a}}
Function application. 

@item @code{@strong{not} a}
@itemx @code{@strong{~}a}
The negation of term @code{a}.

@item @code{a @strong{and} b}
@itemx @code{a @strong{&} b}
The conjunction of terms @code{a} and @code{b}

@item @code{a @strong{or} b}
@itemx @code{a @strong{|} b}
The disjunction of terms @code{a} and @code{b}

@item @code{a @strong{implies} b}
@itemx @code{a @strong{=>} b}
Implication for terms @code{a} and @code{b}

@item @code{a @strong{iff} b}
The boolean of terms @code{a} and @code{b}.

@item @code{a @strong{=} b}
The equality of terms @code{a} and @code{b}.

@item @code{(@var{t}@strong{:}@var{ty})}.
Specifies that term @var{t} has type @var{ty}.
@end table

The operators have the usual priorities, brackets can be used as
normal. Function application has lower priority than other operators
and the equality operator has higher priority than boolean equivalence.

As with the types, a term can have a specialized syntax in addition to
it's form in the standard syntax. For example, sets can be written in
the custom form @code{@{ x :| P @}}, rather than the standard form
@code{SET(%x : P)} that follows from their definition.

@section Binding Terms

Binding terms are lambda-abstractions, the epsilon and the universal
and existential quantifiers. A binding term (with some symbol
@var{SYM}) is written @code{@var{SYM} x : F} and binds variable
@code{x} in term @code{F}. The binding generalizes to a list of
variables: @code{@var{SYM} x1 x2 @dots{} xn : F} binds variables
@code{x1}, @code{x2}, @dots{}, @code{xn} in term @code{F}.

The binding terms are:
@table @code
@item @code{@strong{%} x@strong{:} F}
A lambda term.

@item @code{@strong{!} x@strong{:} F}
Universal quantification.

@item @code{@strong{?} x@strong{:} F}
Existential quantification. 

@item @code{@strong{?!} x@strong{:} F}.
Unique existential binding (i.e. there exists one @code{x} such that
@code{F} is true).

@item @code{@strong{@@} x@strong{:} F}
The choice operator (i.e. some @code{x} for which @code{F} is true)
@end table

A variable @code{x} in a binding can be typed in which case it is
written with brackets as @code{(x: ty)}.  For example
@example 
@code{! x (y: bool) z : ?  (A:('a)set): (y and z) | (x = A)}.
@end example

@chapter Theories

A @emph{theory} is a set of declarations, definitions and theorems. A
theory provides the @emph{scope} in which formulas are constructed.

A theory @var{T} is built from a @emph{script file} named
@code{@var{T}Script.ml}. It is saved to a @emph{theory file} named
@code{@var{T}.tho}. When a theory is built or loaded from a file, it's
parents are also loaded. If the parent of a theory does not have a
theory file, it is rebuilt from it's script file. All theories must be
more recent than the theories they depend on and theories are
automatically rebuilt if necessary.

A theory is either @emph{closed} or @emph{writable}. A closed theory
can be the parent of other theories but cannot be modified. A writable
theory can be modified but can't be used as the parent of another
theory.

The main theory for @HSeq{} is called @code{Main} and is automatically
set as a parent for each new theory.

@section Theory Functions

@table @code
@item @code{@strong{begin_theory} @var{n} [@var{p1}; @dots{}; @var{pn}]}
Begins a theory named @var{n} with parents @var{p1}, @dots{},
@var{pn}.

@item @code{@strong{open_theory} @var{n}}
Opens a writable theory, loading it from it's theory file if needed.
Used to continue work on an incomplete theory closed with @code{close_theory}.

@item @code{@strong{close_theory()}}
Closes a writable theory, saving it to it's theory file.
Used to postpone work on an incomplete theory.

@item @code{@strong{end_theory()}}
Ends the currently open theory, marking it as closed and saving it to
a theory file.

@item @strong{@code{add_file @var{n}}}
Marks file @var{n} as a library to be loaded when the theory is
loaded. If @var{n} ends with suffix @code{.ml}, it is loaded as a
OCaml script (equivalento using @code{#use}). If @var{n} ends with
suffix @code{.cmi} or @code{.cmo} it is loaded as an OCaml library.
@end table

@subsection Query Functions

@table @code
@item @strong{@code{theory @var{x}}}
Displays theory @var{n}. If @var{x} is the empty string (@code{""}),
the current theory is displayed.

@item @strong{@code{defn @var{x}}}
Gets the defining theorem for term @var{x}. If @var{x} is in the form
@code{@var{T}.@var{n}}, it identifies term @var{n} from theory
@var{T}, otherwise the scope is searched for a definition of @var{x}.

@item @strong{@code{thm @var{x}}} 
Get the theorem named @var{x}. Note that axioms are theorems. If
@var{x} is in the form @code{@var{T}.@var{n}}, it identifies theorem
@var{n} from theory @var{T}, otherwise the scope is searched for a
theorem named @var{x}.

@item @strong{@code{scope()}}
Get the current scope. 

@item @strong{@code{goal_scope()}}
Get the scope of the current goal (in an interactive proof).
@end table

@section Declarations and Definitions

@table @code
@item @strong{@code{declare << @var{D} >>}}
Declares a term. @var{D} should be in the form @code{@var{n}:@var{ty}}
where @var{n} is the identifier and @var{ty} the type. Note that
@code{declare} uses the term quotation parser (@code{<< @dots{} >>})
not the definition quotation parser.

Example:
@example
@code{declare << and:(bool -> bool -> bool) >>}.
@end example

@item @strong{@code{define <:def< @var{D} >>}} 
Defines a term. @var{D} must be in the form @code{@var{n} @var{a1}
@dots{} @var{an} = @var{T}} where @var{n} is the identifier being
defined, @var{a1} @dots{}  @var{an} are the parameters and @var{T} the
body of the definition.

Example:
@example
@code{define <:def< or x y = (not (not x) and (not y)) >>}.
@end example

@item @strong{@code{typedef <:def<: @var{D} >>}} 
Declares or defines a type constructor.  @code{typedef <:def<:
@var{ty} >>} declares the new type @var{ty} constructor. @code{typedef
<:def<: @var{ty1} = @var{ty2} >>} declares @var{ty1} to be an alias
for type @var{ty2}.

Example:
@example
(declaration) @code{typedef <:def<: bool >>}
(aliasing)    @code{typedef <:def<: ('a)set = ('a -> bool)>>}.
@end example

@item @strong{@code{typedef ~thm:@var{T} <:def<: @var{ty1} = @var{ty2}:@var{pred} >>}} 
Defines @var{ty1} as the subtype of type @var{ty2} containing elements
which satisfy term @var{pred} (which should have type @code{@var{ty2}
-> bool}). Existence theorem @var{T} must be in the form @code{?x:
@var{pred} x}.

Example
@example 
@code{typedef <:def<: ('a, 'b)PAIR = ('a -> 'b -> boo): is_pair>>}.
@end example

@end table

The declaration and definition commands take an optional argument
named @code{?pp} to specify printer-parser information. This sets the
precedence, fixity and the symbol to use for the identifier or
constructor.

The fixity values are @strong{@code{prefix}}, @strong{@code{infixl}}
(infix, left associative), @strong{@code{infixr}} (infix, right
associative), @strong{@code{infixn}} (infix, non-associative) and
@strong{@code{suffix}}.

@section Axioms and Theorems

@table @code
@item @strong{@code{axiom @var{T}}} 
Declares term @var{T} as an axiom. 

@item @strong{@code{theorem @var{T} [@var{tac1}; @dots{}; @var{tacn}]}}
@itemx @strong{@code{lemma @var{T} [@var{tac1}; @dots{}; @var{tacn}]}}
Adds term @var{T} as a theorem using the list of @emph{tactics}
@var{tac1} @dots{}  @var{tacn} as a proof. A goal is constructed from
term @var{T} and each tactic in the list is applied, in order, to the
first subgoal.

The list of tactics used by @code{theorem} is an unstructured proof:
the tactics are always applied to the first sub-goal, as they are in
interactive proofs. This makes it easier to transfer interactive
proofs to a batch proof.

@item @strong{@code{prove @var{t} @var{tac}}}
Proves the theorem built from term @var{t} using tactic @var{tac},
failing if the tactic fails.
@end table

@code{axiom} and @code{theorem} take the optional argument @code{?simp}
which marks the axiom/theorem for use as a simplification rule.

@chapter Interactive Proofs

Each sequent formula can be identified by a unique @emph{label}. A
string @var{str} can be set as the label for a formula, in which case
the label is referred by the OCaml expression @code{!$
@var{str}}. When a string is set as the label of a sequent formula, it
replaces the integer normally displayed with the formula.

@table @code
@item @strong{@code{goal @var{t}}} 
Set term @var{t} as the goal in an interactive proof.

@item @strong{@code{by @var{tac}}} 
Applies tactic @var{tac} to the current subgoal.

@item @strong{@code{undo()}} 
Drops the result of the last @code{by} command.

@item @strong{@code{top()}} 
Displays the current sub-goal.

@item @code{@strong{qed} @var{n}}
Store the goal as a theorem named @var{n} in the current theory. Fails
if the goal hasn't been proved.

@item @code{@strong{fnum} @var{n}}
@itemx @code{!! @var{n}}
Make a sequent label for the formula numbered @var{n}.

@item @code{@strong{fnum} @var{i}}
@itemx @code{!! @var{i}}
Make a sequent label for the formula numbered @var{i}.

@item @code{@strong{fname} @var{s}}
@itemx @code{!$ @var{s}}
Make a sequent label for the formula labelled with string @var{s}.
A formula can be labelled with a string using tactic @code{name_tac}.

@end table

@section Tactics

In @HSeq{}, a tactic is a fundamental type, defined in module
@code{HSeq.Logic}. These are defined as the type @code{node ->
branch}, where @code{node} is the goal on which a tactic operates and
@code{branch} the resulting sub-goals.

For normal use, the tactics of type @code{HSeq.Tactics.tactic =
Context.t -> Logic.node -> Logic.branch} are more useful. These take a
theory context (managed by the interactive proof mechanism), making it
easier to use definitions and theorems in a proof.

Module @code{HSeq.Tactics} also defines @emph{data tactics},
@code{('a) data_tactic = Context.t -> Logic.node -> ('a *
Logic.branch)}. These are tactics that can extract data from a goal
and are typically used when implementing procedures to pass data from
one tactic to another.

Tactics are generally named with suffix '_tac'. Tactics ending with a
'A' act on the assumptions of a sub-goal. Tactics ending with 'C' act
on the conclusions. Optional arguments are generally named @code{?a}
for an assumption, @code{?c} for a conclusion, @code{?f} for any
sequent formula and @code{?inst} for a list of terms.

@table @code

@item @strong{@code{conjA}}, @strong{@code{conjC}}
@itemx @strong{@code{disjA}}, @strong{@code{disjC}}
@itemx @strong{@code{implA}}, @strong{@code{implC}},
@itemx @strong{@code{negA}}, @strong{@code{negC}}
@itemx @strong{@code{existA}}, @strong{@code{existC}}
@itemx @strong{@code{allA}}, @strong{@code{allC}}
Eliminate conjunctions, disjunctions, implications, negation and
existential and universal quantifiers.

For example,
@example
@table @code
@item conjA reduces 
@code{[@var{A} and @var{B}, @var{asms} |- @var{concls}]}
to
@code{[@var{A}, @var{B}, @var{asms} |- @var{concls}]}

@item conjC splits
@code{[@var{asms} |- @var{A} and @var{B}, @var{concls}]}
to
@code{[@var{asms} |- @var{A}, @var{concls}]}
and @code{[@var{asms} |- @var{B}, @var{concls}]}
@end table
@end example

@item @strong{@code{betaA}}, @strong{@code{betaC}} and @strong{@code{beta_tac}} 
Beta reduce formulas.

For example, 
@example
@table @code
@item betaA reduces 
@code{[(% x: (f x)) true, @var{asms} |- @var{concls}]}
to
@code{[(f true), @var{asms} |- @var{concls}]}
@end table
@end example

@item @strong{@code{basic}} 
Solves sub-goals of the form @code{[@var{F}, @var{asm} |- @var{F},
@var{concl}]} (a formula appearing in both assumptions and
conclusions).

@item @strong{@code{trivial}} 
Solves subgoals in which @code{true} appears in the conclusions or
@code{false} appears in the assumptions.

@item @strong{@code{eq_tac}} 
Solves subgoals in which term @code{x=x} appears in the conclusions.

@item @strong{@code{equals_tac}} 
Replaces equality (=) between booleans with boolean equivalence (iff).

@item @strong{@code{iffA}}, @strong{@code{iffC}} 
Eliminate boolean equivalence.

@item @strong{@code{instA}}, @strong{@code{instC}}, @strong{@code{inst_tac}} 
Instantiate assumptions and conclusions with a given list of
terms. 

@example
@table @code
@item @code{instA [@var{trm}]} reduces 
@code{[! x: f x, @var{asms} |- @var{concls}]}
to
@code{[f @var{trm}, @var{asms} |- @var{concls}]}

@item @code{instC [@var{trm}]} reduces 
@code{[@var{asms} |- ? x: f x, @var{concls}]}
to
@code{[@var{asms} |- f @var{trm}, @var{concls}]}

@end table
@end example

@item @strong{@code{specA}}, @strong{@code{specC}}, @strong{@code{spec_tac}} 
Specialize assumptions and conclusions.

@example
@table @code
@item @code{specA} reduces 
@code{[? x: f x, @var{asms} |- @var{concls}]}
to
@code{[f @var{trm}, @var{asms} |- @var{concls}]}
where @var{trm} is a constructed, arbitrary constant.

@item @code{specC [@var{trm}]} reduces 
@code{[@var{asms} |- ! x: f x, @var{concls}]}
to
@code{[@var{asms} |- f @var{trm}, @var{concls}]}
where @var{trm} is a constructed, arbitrary constant.
@end table
@end example

@item @strong{@code{cut @var{thm}}} 
Introduces theorem @var{thm} as an assumption. The optional argument
@code{?inst} can be used to instantiate the assumption with values.

@item @strong{@code{flatten_tac}} 
Eliminates basic boolean operators without splitting the sub-goal.

@item @strong{@code{split_tac}} 
Eliminates the basic boolean operators, splitting the sub-goal.

@item @strong{@code{scatter_tac}} 
Combines @code{flatten_tac} and @code{split_tac}.

@item @strong{@code{blast_tac}} 
Applies @code{scatter_tac} followed by @code{basic}.

@end table

The order of assumptions and conclusions can be significant for
tactics which search for a formula.  

@table @code
@item @strong{@code{liftA @var{l}}} and @strong{@code{liftC @var{l}}} 
Lift the assumption or conclusion labelled @var{l} to the top of the
list of assumptions or conclusions.

@item @strong{@code{copyA @var{l}}} and @strong{@code{copyC @var{l}}} 
Copy the assumption or conclusion with label @var{l}.

@item @strong{@code{deleteA @var{l}}} and @strong{@code{deleteC @var{l}}}
Delete the assumption or conclusion labelled @var{l}.

@item @strong{@code{nameA @var{str} @var{l}}}
@itemx @strong{@code{nameC @var{str} @var{l}}}
@itemx @strong{@code{name_tac @var{str} @var{l}}}
Set string @var{str} as the label of the assumption, conclusion or
sequent formula with existing label @var{l}. These can be used in
conjunction with @code{match_asm} and @code{match_concl}.

@item @strong{@code{match_asm @var{t} tac}}
@itemx @strong{@code{match_concl @var{t} @var{tac}}}
Search the sequent for an assumption or conclusion matching the term
@var{t}, applying @code{@var{tac} @var{l}} where @var{l} is the label
of the matched formula. Free variables in @var{t} match sub-terms in
the assumptions/conclusions.

@example
Example:
@verbatim
- : HSeq.Goals.Proof.t =
Goal !f x y z: (x | y | z & (f x y z) => (f z y x)) => false
1 subgoal
[~1] _x | _y | _z
[~2] (_f _x _y _z) => (_f _z _y _x)
----------------------
[1] false

# by (match_asm << A => C >> liftA);;
- : HSeq.Goals.Proof.t =
Goal !f x y z: (x | y | z & (f x y z) => (f z y x)) => false
1 subgoal
[~1] (_f _x _y _z) => (_f _z _y _x)
[~2] _x | _y | _z
----------------------
[1] false
@end verbatim
@end example

@end table

Some other tactics include:
@table @code
@item @strong{@code{unify_tac}}
Try to unify an assumption with a conclusion. Fails if no assumption
can be unified with any conclusion. The label assumption and
conclusion can optionally be given.

@item @strong{@code{back_tac}}
Matches a possibly quantified assumption of the from @code{a => c}
with a conclusion of the form @code{c}, replacing the conclusion with
@code{a}.

@item @strong{@code{mp_tac}}
Matches a possibly quantified assumption of the from @code{a => c}
with an assumption of the form @code{a}, replacing it with assumption
@code{c}.

@item @strong{@code{cut_back_tac}} and @strong{@code{cut_mp_tac}} 
Operate with theorems of the form @code{a=>c} (which may be
universally quantified). The conclusion @code{c} is unified with an
assumption and replaced with the assumption @code{a}.

@item @strong{@code{show @var{t} @var{tac}}} 
Introduces term @var{t} as an assumption, using tactic @var{tac} to
prove the truth of @var{t}.

@item @strong{@code{cases_tac @var{t}}} 
Introduces a case split on the truth of term @var{t}.

@item @strong{@code{case_of @var{t}}} 
Introduces a case split on the possible values of term @var{t}. The
type of the term is used to determine the cases theorem used. If
@var{ty} has type @var{ty}, the cases theorem named
@code{@var{ty}_cases} is used.

@example
Example, for boolean term << _x >>
@verbatim
- : HSeq.Goals.Proof.t =
Goal !x: x => false
1 subgoal
[~1] _x
----------------------
[1] false

# by (cases_of << _x >>);;
2 subgoals
(Subgoal 1)
[~1] _x = true
[~2] _x
----------------------
[1] false

(Subgoal 2)
[~1] _x = false
[~2] _x
----------------------
[1] false

- : HSeq.Goals.Proof.t =
Goal !x: x => false
2 subgoals
[~1] _x = true
[~2] _x
----------------------
[1] false
@end verbatim
@end example

@item @strong{@code{induct_tac @var{thm}}} 
Begins a proof by induction on a conclusion of the form @code{! x .. y
: R => A}.

@example
Example:
@verbatim
# goal << !A: (finite A) => (!B : (subset B A) => (finite B)) >>;;
- : HSeq.Goals.Proof.t =
Goal !A: (finite A) => (!B: (subset B A) => (finite B))
1 subgoal
----------------------
[1] !A: (finite A) => (!B: (subset B A) => (finite B))

# by (induct_tac (thm "finite_induct"));;
2 subgoals
(Subgoal 1)
----------------------
[1] !B: (subset B empty) => (finite B)

(Subgoal 2)
----------------------
[1] !x A:
       (~ (in x A) & (!B: (subset B A) => (finite B))) =>
         (!B: (subset B add x A) => (finite B))

- : HSeq.Goals.Proof.t =
Goal !A: (finite A) => (!B: (subset B A) => (finite B))
2 subgoals
 ----------------------
[1] !B: (subset B empty) => (finite B)

@end verbatim
@end example

@item @strong{@code{induct_on @var{n}}} 
Begins a proof by induction on the quantified variable named @var{n},
failing if there is no such variable in the conclusions or no
appropriate induction theorem. The induction theorem used depends on
the type of variable @var{n}: if @var{n} has type @var{ty}, the
induction theorm is expected to be called @code{@var{ty}_induct}.
@end table

@section Rewriting and Simplification

Rewriting works on rewrite rules of the form @code{! @var{x}:
@var{A}(@var{x}) => @var{C}(@var{x})}. Rewrites rules can be theorems
or be assumptions in a sequent, such as those introduced using
tactic @code{cut}.

Some rewriting tactics take an optional argument @code{?dir} to
specify the rewriting direction. The possible values are
@strong{@code{rightleft}} or @strong{@code{leftright}}.

@table @code
@item @strong{@code{rewriteA_tac}}
@itemx @strong{@code{rewriteC_tac}}
@itemx @strong{@code{rewrite_tac}} 
Rewrite tactics for assumptions, conclusions and sequent formulas with
rewrite rules provided as a list of theorems.

@example
Example
@verbatim
# goal << ! x y: (x iff y) => (x => y) >>;;
- : HSeq.Goals.Proof.t =
Goal !x y: (x iff y) => x => y
1 subgoal
----------------------
[1] !x y: (x iff y) => x => y

# defn "iff";;
- : HSeq.Logic.thm = |- !x y: (x iff y) = (x => y & y => x)
# by (rewrite_tac [defn "iff"]);;
- : HSeq.Goals.Proof.t =
Goal !x y: (x iff y) => x => y
1 subgoal
----------------------
[1] !x y: (x => y & y => x) => x => y
@end verbatim
@end example

@item @strong{@code{once_rewriteA_tac}}
@itemx @strong{@code{once_rewriteC_tac}}
@itemx @strong{@code{once_rewrite_tac}}
Apply a rewrite rule once in the assumption, conclusion or anywhere in
the sequent.

@item @strong{@code{replace_tac}}
@itemx @strong{@code{once_replace_tac}}
Rewrite formulas with rules from the assumptions. 

@example
Example
@verbatim
# goal << ! f g x: (f = g) => ((f x) = (g x)) >>;;
- : HSeq.Goals.Proof.t =
Goal !f g x: f = g => (f x) = (g x)
1 subgoal
----------------------
[1] !f g x: f = g => (f x) = (g x)

# by flatten_tac;;
- : HSeq.Goals.Proof.t =
Goal !f g x: f = g => (f x) = (g x)
1 subgoal
[~1] _f = _g
----------------------
[1] (_f _x) = (_g _x)

# by (cut (thm "function_eq"));;
- : HSeq.Goals.Proof.t =
Goal !f g x: f = g => (f x) = (g x)
1 subgoal
[~1] !f g: f = g = (!x: (f x) = (g x))
[~2] _f = _g
----------------------
[1] (_f _x) = (_g _x)

by (once_replace_tac ~f:(!! (-2)));;
- : HSeq.Goals.Proof.t =
Goal !f g x: f = g => (f x) = (g x)
1 subgoal
[~1] !f g: f = g = (!x: (f x) = (g x))
[~2] !x: (_f x) = (_g x)
----------------------
[1] (_f _x) = (_g _x)

# by unify_tac;;
Subgoal solved
- : HSeq.Goals.Proof.t = Goal !f g x: f = g => (f x) = (g x)
                         No subgoals
@end verbatim
@end example

@item @strong{@code{unfold @var{n}}} 
Unfold the definition of term @var{n}.
@end table

The main simplification tactics are @code{simpA_tac},
@code{simpC_tac}, @code{simp_all_tac} and @code{simp_tac}.

@table @code
@item @strong{@code{simpA_tac}} 
Simplifies the assumptions, starting with the first.

@item @strong{@code{simpC_tac}} 
Simplifies the conclusions, starting with the last.

@item @strong{@code{simp_all_tac}} 
Simplifies the assumptions, starting with the first, and then the
conclusions, starting with the last.

@item @strong{@code{simp_tac}}
Simplify a sequent formula, chosen from an optional label. If the
label is given then @code{simp_tac} is either @code{simpC_tac} or
@code{simpA_tac}, otherwise it is @code{simpC_tac}.
@end table

The simplification tactics use the standard simplification rules,
obtained by calling @strong{@code{std_ss()}}. The simplification
tactics ending with @code{_tac} also take a list of theorems to use as
additional simplification rules.

Tactics @strong{@code{simpA}}, @strong{@code{simpC}},
@strong{@code{simp_all}} and @strong{@code{simp}} are short-hand for
the simplification tactics with no additional rules (@code{simp =
simp_tac []}).

@section Tacticals

@table @code
@item @strong{@code{skip}} 
The tactic that does nothing and always succeeds.

@item @strong{@code{fail}}
The tactic that does nothing and always fails.

@item @code{@strong{alt}[@var{tac_1}; @var{tac_2}; @dots{}; @var{tac_n}]}
Alternation between tactics. Each tactic is tried in sequence,
starting with @var{tac_1}, until one of the tactics succeeds. The
alternation fails if all the tactics fail.

@code{@var{tac_1}@strong{//}@var{tac_2}} 
Shorthand for @code{alt[@var{tac_1}; @var{tac_2}]}.

@item @code{@strong{seq}[@var{tac_1}; @var{tac_2}; @dots{}; @var{tac_n}]}
The @strong{sequential composition} of tactics. The tactics are
applied in sequence starting with @var{tac_1}. Each subsequent tactic
@var{tac_(i+1)} is applied to each of the sub-goals generated by
@var{tac_i}. The sequence continues until all tactics have been
applied, the goal is solved or a tactic fails.

@item @code{@var{tac_1}@strong{++}@var{tac_2}}
Shorthand for @code{seq[@var{tac_1}; @var{tac_2}]}.

@item @code{@var{tac} @strong{--} [@var{tac_1}; @dots{}; @var{tac_n}]}
The @strong{branching} tactical. First applies tactic @var{tac} then
each tactic @var{tac_i} is applied to the @var{i}'th resulting
sub-goal. All sub-goals are then combined, in the order they were
generated, to form the final list of sub-goals. 

If there are more sub-goals than tactics, the extra sub-goals are
added to the end of the final list (as if the list of tactics was
padded with @code{skip}). If there are more tactics than sub-goals,
the extra tactics are ignored.

@item @code{@strong{repeat} @var{tac}}
Apply @var{tac} at least once then repeat until it fails
or there are no more subgoals.

@item @code{@strong{cond} @var{pred} @var{tac_1} @var{tac_2}}
Apply predicate @var{pred} to a goal, if the result is @code{true}
then apply @var{tac_1} to the goal otherwise apply @var{tac_2}.

@code{@var{pred} @strong{-->} @var{tac}}
Sshorthand for @code{cond @var{pred} @var{tac} @code{skip}}.
@end table

@c
@c End of document
@c

@bye
