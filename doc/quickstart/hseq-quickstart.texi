\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename hseq-quickstart.info
@settitle HSeq Quick Start

@c %**end of header

@c Local definitions
@include localdefs.texi

@copying
Copyright @copyright{} 2005-2014, Matthew Wahab
@end copying

@titlepage
@title @HSeq{} Quick Start
@author Matthew Wahab <@email{mwb.cde@@gmail.com}>

@page
@vskip 0pt plus lfill
@insertcopying
@end titlepage

@ifnottex
@node Top
@top HSeq Quick Start
@insertcopying
@end ifnottex

@HSeq{} is a tactical theorem prover for a typed, higher order logic
based on the sequent calculus. It is written in OCaml and can 
be used interactively through the OCaml toplevel or as a library
linked into an application. This manual assumes that it is used
through the OCaml toplevel.

@HSeq{} is experimental, alpha-quality code which may have soundness
bugs.

@chapter Interaction with OCaml

@HSeq{} is built as an extension to the OCaml toplevel (@code{ocaml}).

@code{hseq @var{options}} starts the interactive interpreter and makes
the @HSeq{} extensions available @var{options} are the options to pass
to the OCaml system.

@code{hseqb @var{options} @var{file}} executes @var{file} as a script.

@code{reset()} resets the @HSeq{} system to its initial state.

@section Quotations

@HSeq{} terms, types and definitions can be used in OCaml expressions
using quotations of the form @code{<< .. >>}. The accepted forms are:
@table @code
@item @code{<< str >>}
parses @var{str} as a term.
@item @code{<<: str >>}
parses @var{str}  as a type.
@item @code{<:def< str >>}
parses @var{str} as a term definition
@item @code{<:def<: str >>}
parses @var{str} as a type definition or declaration.
@end table

@chapter Overview

@HSeq{} is a system for proving a statement n the logic are true by
constructing a a proof that shows that the can be derived from axioms
of the logic by applying inference rules of the logic. 

A statement in the logic is expressed in @HSeq{} as a @emph{term}
which is constructed from operators and values and which has a
@emph{type}. Similarly, a type can be formed from more constructors
and from more basic types. A term is a @emph{formula} if it is
syntactically well-formed and has a valid type. Definitions and
declarations can be used to introduce new term or type constructors. A
@emph{theorem} is a formula that has been proved to be true; an
@emph{axiom} is a formula that has been declared without proof to be a
true statement.

@section Theories

In @HSeq{}, a @emph{theory} is a record of declaration, definitions
and theorems that provides a context (equivalently, a @emph{scope}) in
which types, terms and proofs can be constructed. A term and or type
is well-formed in a theory iff all constructors and operators used in
term or type are available in the context provided by the theory. A
theory @emph{T} can have one or more @emph{parent} theories. All
declarations, definitions and theorems available in the parent of a
theory are also available in the theory. @HSeq{} theories are
effectively a module system providing a means to structure the
declarations, definitions and theorems that make up a logical theory.

@section Proofs

In @HSeq{}, a proof is made of up a @emph{goal} to be proved and
@emph{tactics} which implement the steps of the proof. A goal is made
up of the formula to be proved and a set of @emph{sequents}. Each
sequent is a sub-goal to be proved and is made up of a set of
@emph{assumptions} and a set of @emph{conclusions}. Initially, a goal
has one sequent with the formula to be proved as the only conclusion.

A goal is manipulated by applying @emph{tactics}, which implement the
inference rules to manipulate and simplify sequents, possibly
introducing new sub-goals that are easier to prove. Tactics can be
combined, using @emph{tacticals}, allowing for complex proof
procedures to be built from the the basic inference rules. 

The proof that a formula is a theorem is constructed as a single
tactic, which can be built as a combination of other tactics.  These
reduce the initial sequent to one or more simpler sub-goals until the
goal is reduced to a set of sequents which are simple enough to be
proved from the basic rules of the logic.

Tactics are functions in OCaml and new tactics can be implemented, in
terms of existing tactics and tacticals, by function definition.

Functions making use of @HSeq{} goals and proofs can also be defined.
A @emph{conversion} is a function that creates a specialized theorem
from a given term. Typically, a conversion of term @code{T} generates
theorem of the form @code{T=true} (or @code{T=false}). A conversion
works by generating a goal trying to construct a proof for the
theorem. If the theorem can't be be proven, the conversion fails.


@chapter Types

A type in the logic has OCaml type @code{Basic.gtype} and is a
@emph{type variable}, a @emph{type constructor} or a @emph{weak type
variable}.

The standard syntax of the types is:
@table @code
@item @code{'a}
 a type variable of name @emph{a}.  
@item @code{'_a} 
 a weak type variable of name @emph{a}.
@item @code{(t1, @dots{}, t@var{n})f}
a constructed type, with constructor identifier @emph{f} and @var{n}
arguments. 
@item @code{f}
a constructed type, with constructor identifier @emph{f} and no arguments. 
@end table

Some types may also have a specialized form that can be used as an
alternative to the standard syntax.

If the identifier @emph{f} is in the form @code{@var{T}.@var{n}} then
it is the constructor named @var{n} declared in the theory named
@var{T}. If @emph{f} is @code{@var{n}}, the scope of the type is
searched for a definition or declaration of @var{n}.

A weak type variable is a type variable which cannot be bound to a
type variable. It can bind only with another weak type variables or
with a a type constructor. Weak type variables occur only in
sequents. If a weak type variable @var{v} is bound to a type @var{t}
in a sequent, all instances of @var{v} are bound to @var{t}. Weak type
variables are treated as ordinary type variables by the parser.

The standard types are: 
@table @code
@item @code{bool}
the booleans
@item @code{'a -> 'b}
functions from @code{'a} to @code{'b}.
@item @code{('a)set} 
sets of @code{'a} 
@item @code{'a * 'b}
the product of @code{'a} and @code{'b}.
@end table

@chapter Terms

A term has OCaml type @code{Basic.term} and is an @emph{identifier}, a
@emph{free variable}, a @emph{bound variable}, a @emph{binding term}
or a function application. Terms have types and a @emph{formula} is a
well-formed term that is correctly typed in some @emph{scope}.

The core terms and their syntax are:
@table @code
@item @code{true}, @code{false}
The boolean true and false.
@item @code{f a}
A function application. 
@item @code{~a}, @code{not a}
The negation of term @code{a}.
@item @code{a & b}, @code{a and b}
The conjunction of terms @code{a} and @code{b}
@item @code{a | b}, @code{a or b}
The disjunction of terms @code{a} and @code{b}
@item @code{a => b}, @code{a implies b}
Implication for terms @code{a} and @code{b}
@item @code{a iff b}
The boolean of terms @code{a} and @code{b}.
@item @code{a = b}
The equality of terms @code{a} and @code{b}.
@item @code{(@var{t}:@var{ty})}.
Specifies that term @var{t} has type @var{ty}.
@item @code{@@ x: F}
The choice operator (i.e. some @code{x} for which @code{F} is true)
@end table

The operators have the usual priorities, brackets can be used as
normal. Function application has lower priority than other operators
and the equality operator has higher priority than boolean equivalent.

A term identifier @var{f} is either in the form @code{@var{T}.@var{n}}
or @var{n}. For @code{@var{T}.@var{n}}, the identifier is the name
@var{n} declared in the theory named @var{T}. If @var{f} is @var{n},
the scope of the term is searched for a list of theories in which
@var{n} is defined or declared. The name @var{n} is resolved by
choosing the first declaration or definition which matches the type of
@var{f}.

Binding terms are lambda-abstractions, the epsilon and the universal
and existential quantifiers. A binding term (with some symbol
@var{SYM}) is written @code{@var{SYM} x : F} and binds variable
@code{x} in term @code{F}. The binding generalizes to a list of
variables: @code{@var{SYM} x1 x2 @dots{} xn : F} binds variables
@code{x1}, @code{x2}, @dots{}, @code{xn} in term @code{F}.

The binding terms are:
@table @code
@item @code{% x: F}
A lambda term.
@item @code{! x: F}
Universal quantification is @code{! x: F} 
@item @code{? x: F}
existential quantification. 
@item @code{?! x: F}.
the unique existential binding (i.e. there exists one @code{x} such
that @code{F} is true).
@end table

A variable @code{x} in a binding can be typed in which case it is
written with brackets as @code{(x: ty)}.  For example
@example 
@code{! x (y: bool) z : ?  (A:('a)set): (y and z) | (x = A)}.
@end example

@chapter Theories

A @emph{theory} is a set of declarations, definitions and theorems. A
theory provides the @emph{scope} in which formulas are constructed.

A theory @var{T} is built from a @emph{script file} named
@code{@var{T}Script.ml}. It is saved to a @emph{theory file} named
@code{@var{T}.tho}.      

A theory can depend on other theories (its @emph{parents}). When a
theory is built or loaded from file, its parents are also loaded. If
the parent of a theory does not have a theory file, it is rebuilt from
its script file. All theories must be younger than the theories they
depend on and theories are automatically rebuilt if necessary.

A theory is either @emph{closed} or @emph{writable}. A closed theory
can be the parent of other theories but cannot be modified. A writable
theory can be modified but cannot be used as the parent of another
theory.

The main theory for @HSeq{} is called @code{Main} and is automatically
set as a parent for each new theory.

@section Theory Functions

@strong{@code{begin_theory @var{n} [@var{p1}; @dots{}; @var{pn}]}}
begins a theory named @var{n} with parents @var{p1}, @dots{},
@var{pn}.

@strong{@code{end_theory()}} ends the currently open theory, marking
it as closed and saving it to a theory file.

@strong{@code{add_file @var{n}}} marks file @var{n} as a library to be
loaded when the theory is loaded. If @var{n} ends with suffix
@code{.ml}, it is loaded using @code{#use}. If @var{n} ends with
suffix @code{.cmi} or @code{.cmo} it is loaded with @code{#load}.

@strong{@code{compile @var{path} @var{n}}} compiles file @var{n} with the
standard @HSeq{} libraries. @var{path} is the list of additional
include directories to use.

@subsection Query Functions

@strong{@code{theory @var{x}}} displays theory @var{n}. If @var{x} is
the empty string (@code{""}), the current theory is displayed.

@strong{@code{defn @var{x}}} gets the defining theorem for term
@var{x}. If @var{x} is in the form @code{@var{T}.@var{n}}, it
identifies term @var{n} from theory @var{T}, otherwise the scope is
searched for a definition of @var{x}.

@strong{@code{thm @var{x}}} get the theorem named @var{x}. Note that axioms are
theorems. If @var{x} is in the form @code{@var{T}.@var{n}}, it
identifies theorem @var{n} from theory @var{T}, otherwise the scope is
searched for a theorem named @var{x}.

@strong{@code{scope()}} get the current scope. 

@strong{@code{goal_scope()}} get the scope of the current goal (in an
interactive proof).

@section Declarations and Definitions

@strong{@code{declare << @var{D} >>}} declares a term. @var{D} should
be in the form @code{@var{n}:@var{ty}} where @var{n} is the identifier
and @var{ty} the type. Note that @code{declare} uses the term
quotation parser (@code{<< @dots{} >>}) not the definition quotation
parser.

Example:
@example
@code{declare <:def< and:(bool -> bool -> bool) >>}.
@end example

@strong{@code{define <:def< @var{D} >>}} defines a term. @var{D} must
be in the form @code{@var{n} @var{a1} @dots{} @var{an} = @var{T}}
where @var{n} is the identifier being defined, @var{a1} @dots{}
@var{an} are the parameters and @var{T} the body of the definition.

Example:
@example
@code{define <:def< or x y = (not (not x) and (not y)) >>}.
@end example

@strong{@code{typedef <:def<: @var{D} >>}} declares or defines a type
constructor.  @code{typedef <:def<: @var{ty} >>} declares the new type
@var{ty} constructor. @code{typedef <:def<: @var{ty1} = @var{ty2} >>}
declares @var{ty1} to be an alias for type @var{ty2}.  

Example:
@example
(declaration) @code{typedef <:def<: bool >>}
(aliasing) @code{typedef <:def<: ('a)set = ('a -> bool)>>}.
@end example

@strong{@code{typedef ~thm:@var{T} <:def<: @var{ty1} =
@var{ty2}:@var{pred} >>}} defines @var{ty1} as the subtype of type
@var{ty2} containing elements which satisfy term @var{pred} (which
should have type @code{@var{ty2} -> bool}). Existence theorem @var{T}
must be in the form @code{?x: @var{pred} x}.

Example
@example 
@code{typedef <:def<: ('a, 'b)PAIR = ('a -> 'b -> boo): is_pair>>}.
@end example

The declaration and definition commands take an optional argument
named @code{pp} to specify printer-parser information. This sets the
precedence, fixity and the symbol to use for the identifier or
constructor.

Fixity values are @code{prefix}, @code{infixl} (infix, left
associative), @code{infixr} (infix, right associative), @code{infixn}
(infix, non-associative) and @code{suffix}.

@section Axioms and Theorems

@strong{@code{axiom @var{T}}} declares term @var{T} as an axiom. 

@strong{@code{theorem @var{T} [@var{tac1}; @dots{}; @var{tacn}]}} adds term
@var{T} as a theorem using the list of @emph{tactics} @var{tac1} @dots{}
@var{tacn} as a proof. A goal is constructed from term @var{T} and
each tactic in the list is applied, in order, to the first subgoal.

Note that the list of tactics used by @code{theorem} is an
unstructured proof: the tactics are always applied to the first
sub-goal, as they are in interactive proofs. This makes it easier to
transfer interactive proofs to a batch proof.

@code{axiom} and @code{theorem} take the optional argument @code{simp}
which marks the axiom/theorem for use as a simplification rule.

@chapter Interactive Proofs

In sequent @code{@var{asm} |- @var{concl}}, @var{asm} is the list of
assumptions and @var{concl} is the list of conclusions. The
assumptions and the conclusions are the @emph{formulas} of the
sequent. The terms sequent and sub-goal will be used interchangeably.

When a sequent is displayed, the assumptions are printed before the
conclusions, separated by a line.  Each assumption is printed with a
negative integer, starting with @code{-1} and each assumption is
printed with a positive integer, starting with @code{1}. The
@emph{first assumption} is numbered @code{-1}, the @emph{first
conclusion} is numbered @code{1}.

Each sequent formula can be identified by a unique @emph{label}. A
string @var{str} can be set as the label for a formula, in which case
the label is referred by the OCaml expression @code{!$
@var{str}}. When a string is set as the label of a sequent formula, it
replaces the integer normally displayed with the formula.

@strong{@code{goal @var{t}}} sets term @var{t} as the goal 
in an interactive proof.

@strong{@code{by @var{tac}}} applies tactic @var{tac}
to the current subgoal. 

@strong{@code{undo()}} drops the result of the last
@code{by} command. 

@strong{@code{top()}} displays the current sub-goal.

@strong{@code{prove @var{t} @var{tac}}} proves the theorem built from
term @var{t} using tactic @var{tac}, failing if the tactic fails.

@section Tactics

Tactics are generally named with suffix '_tac'. Tactics ending with a
'A' act on the assumptions of a sub-goal. Tactics ending with 'C' act
on the conclusions. Optional arguments are generally named @var{a} for
an assumption, @var{c} for a conclusion, @var{f} for an assumption or
conclusion and @var{inst} for a list of terms.

The @strong{basic tactics} are @code{conjA}, @code{conjC},
@code{disjA}, @code{disjC}, @code{implA}, @code{implC}, @code{negA},
@code{negC}, @code{existA}, @code{existC}, @code{allA}, @code{allC}
which eliminate conjunctions, disjunctions, implications, negation and
existential and universal quantifiers. 

@strong{@code{betaA}}, @strong{@code{betaC}} and
@strong{@code{beta_tac}} beta reduce formulas.

@strong{@code{basic}} solves sub-goals of the form @code{t,
@var{asm}|- t, @var{concl}} (a formula appearing in both assumptions
and conclusions).

@strong{@code{trivial}} solves subgoals in which @code{true}
appears in the conclusions or @code{false} appears in the
assumptions. 

@strong{@code{eq_tac}} solves subgoals in which term @code{x=x}
appears in the conclusions.

@strong{@code{flatten_tac}} eliminates basic boolean operators without
splitting the sub-goal. 

@strong{@code{split_tac}} eliminates the basic boolean operators,
splitting the sub-goal.

@strong{@code{scatter_tac}} combines @code{flatten_tac} and
@code{split_tac}.

@strong{@code{blast_tac}} is @code{scatter_tac} followed by
@code{basic}.

@strong{@code{iffA}} and @strong{@code{iffC}} eliminate boolean
equivalence and

@strong{@code{equals_tac}} replaces equality (=) between booleans with
boolean equivalence (iff).

@strong{@code{instA}}, @strong{@code{instC}} instantiate assumptions
and conclusions with a given list of terms. @strong{@code{inst_tac}} first
tries @code{instA} then @code{instC}. 

@strong{@code{specA}}, @strong{@code{specC}} and
@strong{@code{spec_tac}} specialize assumptions and conclusions.

@strong{@code{cut @var{thm}}} introduces theorem @var{thm} as an
assumption. The optional argument @code{inst} can be used to
instantiate the assumption with values.

The order of assumptions and conclusions can be significant for
tactics which search for a formula.  

@strong{@code{liftA @var{l}}} and @strong{@code{liftC @var{l}}} lift
the assumption or conclusion labelled @var{l} to the front of the list
of assumptions or conclusions.

@strong{@code{copyA @var{l}}} and @strong{@code{copyC @var{l}}} copy
the assumption or conclusion with label @var{l}. 

@strong{@code{deleteA @var{l}}} and @strong{@code{deleteC @var{l}}}
delete the assumption or conclusion labelled @var{l}.

@strong{@code{match_asm @var{t} tac}} and @strong{@code{match_concl
@var{t} @var{tac}}} search the sequent for an assumption or conclusion
matching the term @var{t}, applying @code{@var{tac} @var{l}} where
@var{l} is the label of the matched formula. Free variables in @var{t}
match sub-terms in the assumptions/conclusions. 

Example:
@example
@samp{match_asm << !x y z: A => C >> liftA}.
@end example

@strong{@code{nameA @var{str} @var{l}}} and @strong{@code{nameC
@var{str} @var{l}}} set string @var{str} as the label of the
assumption or conclusion with label @var{l}. These should be used in
conjunction with @code{match_asm} and @code{match_concl}.

@strong{@code{back_tac}} matches a possibly quantified assumption of
the from @code{a => c} with a conclusion of the form @code{c},
replacing the conclusion with @code{a}.

@strong{@code{mp_tac}} matches a possibly quantified assumption of the
from @code{a => c} with an assumption of the form @code{a}, replacing
it with assumption @code{c}.

@strong{@code{cut_back_tac}} and @strong{@code{cut_mp_tac}} operate
with theorems of the form @code{a=>c} (which may be universally
quantified).

@strong{@code{show @var{t} @var{tac}}} introduces term @var{t} as an
assumption, using tactic @var{tac} to prove the truth of
@var{t}. 

@strong{@code{cases_tac @var{t}}} introduces a case split on the truth
of term @var{t}. 

@strong{@code{case_of @var{t}}} introduces a case split on the
possible values of term @var{t}.

@strong{@code{induct_tac @var{thm}}} begins a proof by induction on a
conclusion of the form @code{! x .. y : R => A}. 

@strong{@code{induct_on @var{n}}} begins a proof by induction on the
quantified variable named @var{n}, failing if there is no such
variable in the conclusions or no appropriate induction theorem. The
induction theorem used depends on the type of variable @var{n}.

@section Rewriting and Simplification

Rewriting works on rewrite rules of the form @code{! @var{x}:
@var{A}(@var{x}) => @var{C}(@var{x})}. Rewrites rules can be theorems
or be assumptions in a sequent, e.g. introduced using @code{cut}.

A rewrite tactics may take an optional argument @code{dir} to specify
the rewriting direction. Possible values are @strong{@code{rightleft}}
or @strong{@code{leftright}}.

@strong{@code{rewriteA_tac}}, @strong{@code{rewriteC_tac}} and
@strong{@code{rewrite_tac}} rewrite assumptions, conclusions and sequent
formulas with a list of rewrite rules, provided as theorems. 

@strong{@code{once_rewriteA_tac}}, @strong{@code{once_rewriteC_tac}}
and @strong{@code{once_rewrite_tac}} apply a rewrite rule once.

@strong{@code{replace_tac}} and @strong{@code{once_replace_tac}}
rewrite formulas with rules from the assumptions. 

@strong{@code{unfold @var{n}}} unfolds the definition of the term
@var{n}.

The main simplification tactics are @code{simpA_tac},
@code{simpC_tac}, @code{simp_all_tac} and
@code{simp_tac}.

@strong{@code{simpA_tac}} simplifies the assumptions, starting with
the first.

@strong{@code{simpC_tac}} simplifies the conclusions, starting with
the last.

@strong{@code{simp_all_tac}} simplifies the assumptions, starting with
the first, and then the conclusions, starting with the last.

@strong{@code{simp_tac}} takes an optional formula
label. If the label is given, then @code{simp_tac} is either
@code{simpC_tac} or @code{simpA_tac}, otherwise it is
@code{simpC_tac}.

The simplification tactics use the standard simplification rules,
obtained by calling @strong{@code{std_ss()}}. The simplification
tactics ending with @code{_tac} also take a list of theorems to use as
additional simplification rules. 

Tactics @strong{@code{simpA}}, @strong{@code{simpC}},
@strong{@code{simp_all}} and @strong{@code{simp}} are short-hand for
the simplification tactics with no additional rules (@code{simp =
simp_tac []}).

@section Tacticals

@strong{@code{skip}} is the tactic that does nothing and always
succeeds. 

@strong{@code{fail}} is the tactic that does nothing and always
fails.

The @strong{sequential composition} of tactics is
@strong{@code{seq[@var{tac1}; @var{tac2}; @dots{};
@var{tacn}]}}. The tactics are applied in sequence starting with
@var{tac1} and each tactic @var{tac_(i+1)} is applied to all the
sub-goals generated by @var{taci}. The sequence continues until all
tactics have been applied, the goal is solved or a tactic fails.

@strong{@code{@var{tac1}++@var{tac2}}} is shorthand for @code{seq[@var{tac1};
@var{tac2}]}. 

@strong{@code{alt[@var{tac1}; @var{tac2}; @dots{}; @var{tacn}]}} is
alternation between tactics. Each tactic is tried in sequence,
starting with @var{tac1}, until one of the tactics succeeds. The
alternation fails if all the tactics fail.

@strong{@code{@var{tac1}//@var{tac2}}} is shorthand for
@code{alt[@var{tac1}; @var{tac2}]}.

@strong{Branching} tactical @strong{@code{@var{tac} -- [@var{tac1}; @dots{};
@var{tacn}]}} applies tactic @var{tac}. Each tactic @var{taci} is then
applied to the @var{i}'th resulting sub-goal. All sub-goals are then
combined (in the order they were generated) to form the final list of
sub-goals. If there are more sub-goals than tactics, the extra
sub-goals are added to the end of the final list (as if the list of
tactics was padded with @code{skip}). If there are more tactics than
sub-goals, the extra tactics are ignored.

@c
@c End of document
@c

@bye
